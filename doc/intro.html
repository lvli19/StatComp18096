<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Lvli" />

<meta name="date" content="2019-01-11" />

<title>Answers of StatComp course</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Answers of StatComp course</h1>
<h4 class="author"><em>Lvli</em></h4>
<h4 class="date"><em>2019-01-11</em></h4>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p><strong>StatComp18096</strong> is a simple R package developed to present the homework answers for the ‘Statistical Computing’ course.</p>
</div>
<div id="st-20180914" class="section level2">
<h2><font color="Teal">1st 2018/09/14</font></h2>
<div id="question" class="section level3">
<h3>Question</h3>
<p>Implement at least three examples of different types from the book ??R for Beginners??, “Statistical Computing with R”.</p>
<p>Show the answers with texts, numerical results, tables, and figures.</p>
</div>
<div id="answers" class="section level3">
<h3>Answers</h3>
<p><strong>Example 1 - How to plot (R for Beginners P45)</strong></p>
<p>The example shows us the way to plot a nice figure by using plot parameters and Par function.</p>
<p><strong><em>Generating ten pairs of random values from normal distribtion.</em></strong></p>
<p>Before showing the figures, ten pairs of random values are established as following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x&lt;-<span class="kw">rnorm</span>(<span class="dv">10</span>)
y&lt;-<span class="kw">rnorm</span>(<span class="dv">10</span>)
<span class="kw">rbind</span>(x,y)</code></pre></div>
<p><strong><em>FIGURE 1.1</em></strong></p>
<p>The first plot is displayed in black and white.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x,y)</code></pre></div>
<p><strong><em>FIGURE 1.2</em></strong> The second plot is much better using option value to replace the default value.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># replace some plotting parameters</span>
<span class="kw">plot</span>(x,y,<span class="dt">xlab=</span><span class="st">&quot;Ten random values&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;Ten other values&quot;</span>,<span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">pch=</span><span class="dv">22</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>,<span class="dt">bg=</span><span class="st">&quot;yellow&quot;</span>,<span class="dt">bty=</span><span class="st">&quot;l&quot;</span>,<span class="dt">tcl=</span><span class="fl">0.4</span>,<span class="dt">main=</span><span class="st">&quot;How to customize a plot with R&quot;</span>,<span class="dt">las=</span><span class="dv">1</span>,<span class="dt">cex=</span><span class="fl">1.5</span>)</code></pre></div>
<p><strong><em>FIGURE 1.3</em></strong></p>
<p>Par can be used to set or query graphical parameters. The default drawing parameters are copied to the list opar and we continue modify the former plot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opar &lt;-<span class="st"> </span><span class="kw">par</span>()
<span class="kw">par</span>(<span class="dt">bg=</span><span class="st">&quot;lightyellow&quot;</span>, <span class="dt">col.axis=</span><span class="st">&quot;blue&quot;</span>, <span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="fl">2.5</span>, <span class="fl">0.25</span>))
<span class="kw">plot</span>(x, y, <span class="dt">xlab=</span><span class="st">&quot;Ten random values&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Ten other values&quot;</span>,
<span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">pch=</span><span class="dv">22</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">bg=</span><span class="st">&quot;yellow&quot;</span>,
<span class="dt">bty=</span><span class="st">&quot;l&quot;</span>, <span class="dt">tcl=</span><span class="op">-</span>.<span class="dv">25</span>, <span class="dt">las=</span><span class="dv">1</span>, <span class="dt">cex=</span><span class="fl">1.5</span>)
<span class="kw">title</span>(<span class="st">&quot;How to customize a plot with R (bis)&quot;</span>, <span class="dt">font.main=</span><span class="dv">3</span>, <span class="dt">adj=</span><span class="dv">1</span>)</code></pre></div>
<p><strong><em>FIGURE 1.4</em></strong></p>
<p>We used here plot function to draw a “blank” figure, and then use low-level functions to add points, coordinate axes, labels, etc. By doing so, we can totally control the graphic drawing.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">opar &lt;-<span class="st"> </span><span class="kw">par</span>()
<span class="co"># change the backgroud and margin</span>
<span class="kw">par</span>(<span class="dt">bg=</span><span class="st">&quot;lightgray&quot;</span>, <span class="dt">mar=</span><span class="kw">c</span>(<span class="fl">2.5</span>, <span class="fl">1.5</span>, <span class="fl">2.5</span>, <span class="fl">0.25</span>))
<span class="co"># plot a blank figure</span>
<span class="kw">plot</span>(x, y, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">xaxt=</span><span class="st">&quot;n&quot;</span>, <span class="dt">yaxt=</span><span class="st">&quot;n&quot;</span>)
<span class="co"># change the color of the drawing area</span>
<span class="kw">rect</span>(<span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dt">col=</span><span class="st">&quot;cornsilk&quot;</span>)
<span class="kw">points</span>(x, y, <span class="dt">pch=</span><span class="dv">10</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">cex=</span><span class="dv">2</span>)
<span class="kw">axis</span>(<span class="dt">side=</span><span class="dv">1</span>, <span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="dt">tcl=</span><span class="op">-</span><span class="fl">0.2</span>, <span class="dt">labels=</span><span class="ot">FALSE</span>)
<span class="kw">axis</span>(<span class="dt">side=</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">tcl=</span><span class="op">-</span><span class="fl">0.2</span>, <span class="dt">labels=</span><span class="ot">FALSE</span>)
<span class="kw">title</span>(<span class="st">&quot;How to customize a plot with R (ter)&quot;</span>, <span class="dt">font.main=</span><span class="dv">4</span>, <span class="dt">adj=</span><span class="dv">1</span>, <span class="dt">cex.main=</span><span class="dv">1</span>)
<span class="kw">mtext</span>(<span class="st">&quot;Ten random values&quot;</span>, <span class="dt">side=</span><span class="dv">1</span>, <span class="dt">line=</span><span class="dv">1</span>, <span class="dt">at=</span><span class="dv">1</span>, <span class="dt">cex=</span><span class="fl">0.9</span>, <span class="dt">font=</span><span class="dv">3</span>)
<span class="kw">mtext</span>(<span class="st">&quot;Ten other values&quot;</span>, <span class="dt">line=</span><span class="fl">0.5</span>, <span class="dt">at=</span><span class="op">-</span><span class="fl">1.8</span>, <span class="dt">cex=</span><span class="fl">0.9</span>, <span class="dt">font=</span><span class="dv">3</span>)
<span class="kw">mtext</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="dt">side=</span><span class="dv">1</span>, <span class="dt">las=</span><span class="dv">1</span>, <span class="dt">at=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="dt">line=</span><span class="fl">0.3</span>,
<span class="dt">col=</span><span class="st">&quot;blue&quot;</span>, <span class="dt">cex=</span><span class="fl">0.9</span>)
<span class="kw">mtext</span>(<span class="op">-</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">side=</span><span class="dv">2</span>, <span class="dt">las=</span><span class="dv">1</span>, <span class="dt">at=</span><span class="op">-</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">line=</span><span class="fl">0.2</span>, <span class="dt">col=</span><span class="st">&quot;blue&quot;</span>, <span class="dt">cex=</span><span class="fl">0.9</span>)</code></pre></div>
<p><strong>Example 2 - densityplot (R for Beginners P50)</strong></p>
<p>Generating a Random independent normal samples, which is divided into nine subsamples.</p>
<p>Using densityplot function to plot for each subsample.</p>
<p>panel.densityplot is used to plot empirical density function, panel.mathdensity is used to plot the fitted normal distribution density function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;lattice&quot;</span>)
n &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">5</span>, <span class="dv">45</span>, <span class="dv">5</span>)
x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">sum</span>(n))
y &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">rep</span>(n, n), <span class="dt">labels=</span><span class="kw">paste</span>(<span class="st">&quot;n =&quot;</span>, n))
<span class="kw">densityplot</span>(<span class="op">~</span><span class="st"> </span>x <span class="op">|</span><span class="st"> </span>y, 
            <span class="dt">panel =</span> <span class="cf">function</span>(x, ...) {
              <span class="kw">panel.densityplot</span>(x, <span class="dt">col=</span><span class="st">&quot;DarkOliveGreen&quot;</span>, ...)
              <span class="kw">panel.mathdensity</span>(<span class="dt">dmath=</span>dnorm,
                                <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">mean=</span><span class="kw">mean</span>(x), <span class="dt">sd=</span><span class="kw">sd</span>(x)),
                                <span class="dt">col=</span><span class="st">&quot;darkblue&quot;</span>)
              })</code></pre></div>
<p><strong>Example 3 - xyplot &amp; splom (R for Beginners P51)</strong></p>
<p><strong><em>Earthquake data</em></strong> This example shows the geographic location of earthquakes at different depths.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(quakes)
mini &lt;-<span class="st"> </span><span class="kw">min</span>(quakes<span class="op">$</span>depth)
maxi &lt;-<span class="st"> </span><span class="kw">max</span>(quakes<span class="op">$</span>depth)
int &lt;-<span class="st"> </span><span class="kw">ceiling</span>((maxi <span class="op">-</span><span class="st"> </span>mini)<span class="op">/</span><span class="dv">9</span>)
inf &lt;-<span class="st"> </span><span class="kw">seq</span>(mini, maxi, int)
quakes<span class="op">$</span>depth.cat &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">floor</span>(((quakes<span class="op">$</span>depth <span class="op">-</span><span class="st"> </span>mini) <span class="op">/</span><span class="st"> </span>int)),
<span class="dt">labels=</span><span class="kw">paste</span>(inf, inf <span class="op">+</span><span class="st"> </span>int, <span class="dt">sep=</span><span class="st">&quot;-&quot;</span>))  <span class="co"># add the labels with paste</span>
<span class="kw">xyplot</span>(lat <span class="op">~</span><span class="st"> </span>long <span class="op">|</span><span class="st"> </span>depth.cat, <span class="dt">data =</span> quakes) <span class="co"># split according to depth.cat</span></code></pre></div>
<p><strong><em>Iris data</em></strong> Compared with the former example, this xyplot uses panel.superpose drawing the overlapped groups in the same diagram</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(iris)
<span class="kw">xyplot</span>(
Petal.Length <span class="op">~</span><span class="st"> </span>Petal.Width, <span class="dt">data =</span> iris, <span class="dt">groups=</span>Species,
<span class="dt">panel =</span> panel.superpose,
<span class="dt">type =</span> <span class="kw">c</span>(<span class="st">&quot;p&quot;</span>, <span class="st">&quot;smooth&quot;</span>), <span class="dt">span=</span>.<span class="dv">75</span>,
<span class="dt">auto.key =</span> <span class="kw">list</span>(<span class="dt">x =</span> <span class="fl">0.15</span>, <span class="dt">y =</span> <span class="fl">0.85</span>) <span class="co"># legend,relevant location (0,1)</span>
)</code></pre></div>
<p>splom(~ x) is used to plot two-dimensional graph matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">splom</span>(
<span class="op">~</span>iris[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], <span class="dt">groups =</span> Species, <span class="dt">data =</span> iris, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>,
<span class="dt">panel =</span> panel.superpose,
<span class="dt">auto.key =</span> <span class="kw">list</span>(<span class="dt">columns =</span> <span class="dv">3</span>)
)</code></pre></div>
<p><strong>Example 4 - stratified sampling (“Statistical Computing with R” P146)</strong> Stratified sampling is implemented in a more general way, for the Monte Carlo estimate of <span class="math inline">\(\int_0^1e^{-x}(1+x^2)^{-1}dx\)</span>. The standard Monte Carlo estimate is also obtained for comparison.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    M &lt;-<span class="st"> </span><span class="dv">10000</span>  <span class="co">#number of replicates</span>
    k &lt;-<span class="st"> </span><span class="dv">10</span>     <span class="co">#number of strata</span>
    r &lt;-<span class="st"> </span>M <span class="op">/</span><span class="st"> </span>k  <span class="co">#replicates per stratum</span>
    N &lt;-<span class="st"> </span><span class="dv">50</span>     <span class="co">#number of times to repeat the estimation</span>
    T2 &lt;-<span class="st"> </span><span class="kw">numeric</span>(k)
    estimates &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, N, <span class="dv">2</span>)

    g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
        <span class="kw">exp</span>(<span class="op">-</span>x <span class="op">-</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">1</span><span class="op">+</span>x<span class="op">^</span><span class="dv">2</span>)) <span class="op">*</span><span class="st"> </span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">*</span><span class="st"> </span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)
        }

    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N) {
        estimates[i, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">g</span>(<span class="kw">runif</span>(M)))
        <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>k)
            T2[j] &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">g</span>(<span class="kw">runif</span>(M<span class="op">/</span>k, (j<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>k, j<span class="op">/</span>k)))
        estimates[i, <span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(T2)
    }
<span class="co">#The result of this simulation produces the following estimates.</span>
    <span class="kw">apply</span>(estimates, <span class="dv">2</span>, mean)
    <span class="kw">apply</span>(estimates, <span class="dv">2</span>, var)</code></pre></div>
<p>This represents a more than 98% reduction in variance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">### Plot importance functions in Figures 5.1(a) and 5.1.(b)

    <span class="co">#par(ask = TRUE) #uncomment to pause between graphs</span>

    x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, .<span class="dv">01</span>)
    w &lt;-<span class="st"> </span><span class="dv">2</span>
    f1 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x)
    f2 &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>pi) <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>x<span class="op">^</span><span class="dv">2</span>)
    f3 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x) <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">1</span>))
    f4 &lt;-<span class="st"> </span><span class="dv">4</span> <span class="op">/</span><span class="st"> </span>((<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>x<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>pi)
    g &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x) <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>x<span class="op">^</span><span class="dv">2</span>)

    <span class="co">#for color change lty to col</span>

    <span class="co">#figure (a)</span>
    <span class="kw">plot</span>(x, g, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>,
         <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">2</span>), <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, g<span class="op">/</span>g, <span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, f1, <span class="dt">lty =</span> <span class="dv">3</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, f2, <span class="dt">lty =</span> <span class="dv">4</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, f3, <span class="dt">lty =</span> <span class="dv">5</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, f4, <span class="dt">lty =</span> <span class="dv">6</span>, <span class="dt">lwd =</span> w)
    <span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;g&quot;</span>, <span class="dv">0</span><span class="op">:</span><span class="dv">4</span>),
           <span class="dt">lty =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">lwd =</span> w, <span class="dt">inset =</span> <span class="fl">0.02</span>)

    <span class="co">#figure (b)</span>
    <span class="kw">plot</span>(x, g, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>,
        <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="fl">3.2</span>), <span class="dt">lwd =</span> w, <span class="dt">lty =</span> <span class="dv">2</span>)
    <span class="kw">lines</span>(x, g<span class="op">/</span>f1, <span class="dt">lty =</span> <span class="dv">3</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, g<span class="op">/</span>f2, <span class="dt">lty =</span> <span class="dv">4</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, g<span class="op">/</span>f3, <span class="dt">lty =</span> <span class="dv">5</span>, <span class="dt">lwd =</span> w)
    <span class="kw">lines</span>(x, g<span class="op">/</span>f4, <span class="dt">lty =</span> <span class="dv">6</span>, <span class="dt">lwd =</span> w)
    <span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">4</span>),
           <span class="dt">lty =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">lwd =</span> w, <span class="dt">inset =</span> <span class="fl">0.02</span>)</code></pre></div>
<p><strong><em>Example 5 -Estimating a confidence level (“Statistical Computing with R” P159)</em></strong></p>
<p>Example 6.4 (Confidence interval for variance)</p>
<p>If <span class="math inline">\(X_1,...,X_n\)</span> is a random sample from a <span class="math inline">\(Normal(??, ??^2)\)</span> distribution, n ?? 2, and <span class="math inline">\(S^2\)</span> is the sample variance, then <span class="math inline">\(V = \frac{(n - 1)S^2}{??2} ?? \chi^2(n - 1)\)</span>.</p>
<p>A one side <span class="math inline">\(100(1-\alpha)\%\)</span> confidence interval is given by <span class="math inline">\((0,\frac{(n-1)S2}{\chi^2\alpha})\)</span>, where <span class="math inline">\(\chi^2_\alpha\)</span> is the <span class="math inline">\(\alpha\)</span>-quantile of the <span class="math inline">\(\chi^2(n-1)\)</span> distribution. If the sampled population is normal with variance <span class="math inline">\(\sigma^2\)</span>, then the probability that the confidence interval contains <span class="math inline">\(\sigma^2\)</span> is <span class="math inline">\(1-\alpha\)</span>.</p>
<p>The calculation of the 95% upper confidence limit (UCL) for a random sample size n = 20 from a <span class="math inline">\(Normal(0, \sigma^2 = 4)\)</span> distribution is shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> n &lt;-<span class="st"> </span><span class="dv">20</span>
    alpha &lt;-<span class="st"> </span>.<span class="dv">05</span>
    x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span><span class="dv">2</span>)
    UCL &lt;-<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span><span class="kw">var</span>(x) <span class="op">/</span><span class="st"> </span><span class="kw">qchisq</span>(alpha, <span class="dt">df=</span>n<span class="op">-</span><span class="dv">1</span>)
    <span class="kw">print</span>(UCL)</code></pre></div>
<p>The confidence level is exactly <span class="math inline">\(P(\frac{19S^2}{\chi_{0.05}^2(19)}&gt;4)=P(\frac{(n-1)S^2}{\alpha^2}&gt;\chi_{0.05}(n-1))=0.95\)</span></p>
</div>
</div>
<div id="nd-20180920" class="section level2">
<h2><font color="Teal">2nd 2018/09/20</font></h2>
<div id="exercises-3.5.pages-94" class="section level3">
<h3>Exercises 3.5.(pages 94)</h3>
<p>A discrete random variable X has probability mass function</p>
<p>Use the inverse transform method to generate a random sample of size 1000 from the distribution of X.</p>
<p>Construct a relative frequency table and compare the empirical with the theoretical probabilities. Repeat using the R sample function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x&lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">4</span>
prob &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.1</span>,<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.3</span>)
    cp &lt;-<span class="st"> </span><span class="kw">cumsum</span>(prob); m &lt;-<span class="st"> </span><span class="dv">1000</span>; r &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
    r &lt;-<span class="st"> </span>x[<span class="kw">findInterval</span>(<span class="kw">runif</span>(m),cp)<span class="op">+</span><span class="dv">1</span>]
    ct &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">table</span>(r)); ctfre&lt;-ct<span class="op">/</span><span class="kw">sum</span>(ct);  ctdif&lt;-ct<span class="op">/</span><span class="kw">sum</span>(ct)<span class="op">/</span>prob
<span class="co"># generate a random sample of size 1000</span>
n &lt;-<span class="st"> </span><span class="dv">1000</span>
a &lt;-<span class="st"> </span><span class="kw">sample</span>(x,<span class="dt">size =</span> n,<span class="dt">prob =</span> prob ,<span class="dt">replace =</span> <span class="ot">TRUE</span>)
<span class="co"># compute the frequency</span>
a &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">table</span>(a))
a.fre &lt;-<span class="st"> </span>a<span class="op">/</span>n<span class="op">/</span>prob
diffe1 &lt;-<span class="st"> </span>a.fre
diffe2 &lt;-<span class="st"> </span>ctdif
data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(x,ct,a,ctfre,a.fre,prob,diffe1,diffe2)
<span class="kw">colnames</span>(data) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;ct-num&quot;</span>,<span class="st">&quot;sample-num&quot;</span>,<span class="st">&quot;ct-freq&quot;</span>,<span class="st">&quot;samp-freq&quot;</span>,<span class="st">&quot;prob&quot;</span>,<span class="st">&quot;dif1&quot;</span>,<span class="st">&quot;dif2&quot;</span>)
data</code></pre></div>
<div id="states" class="section level4">
<h4>States</h4>
<p>The dataframe shows that the sample is great because both of the empirical probabilities generated by sample function and inverse transformation method are near to the theoretical prob.</p>
<p>For save space, I did not show you the sample data.</p>
<p><br /><br /></p>
</div>
</div>
<div id="exercises-3.7.pages-94" class="section level3">
<h3>Exercises 3.7.(pages 94)</h3>
<p>Write a function to generate a random sample of size n from the Beta(a, b) distribution by the acceptance-rejection method.</p>
<p>Generate a random sample of size 1000 from the Beta(3,2) distribution.</p>
<p>Graph the histogram of the sample with the theoretical Beta(3,2) density superimposed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># write the function</span>
rBeta &lt;-<span class="st"> </span><span class="cf">function</span>(n,a,b){
  k &lt;-<span class="st"> </span><span class="dv">0</span>; j &lt;-<span class="st"> </span><span class="dv">0</span>
  y &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
  <span class="cf">while</span> (k <span class="op">&lt;</span><span class="st"> </span>n) {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
    j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>) <span class="co">#random variate from g</span>
    c &lt;-<span class="st"> </span><span class="kw">prod</span>(<span class="dv">2</span><span class="op">:</span>(a<span class="op">+</span>b<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span><span class="kw">prod</span>(<span class="dv">2</span><span class="op">:</span>(a<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span><span class="kw">prod</span>(<span class="dv">2</span><span class="op">:</span>(b<span class="op">-</span><span class="dv">1</span>))
    r &lt;-<span class="st"> </span>x<span class="op">^</span>(a<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span>(b<span class="op">-</span><span class="dv">1</span>)
    <span class="cf">if</span> (r <span class="op">&gt;</span><span class="st"> </span>u) {
      <span class="co">#we accept x</span>
      k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
      y[k] &lt;-<span class="st"> </span>x
    }
    }
  y
  }

<span class="co"># Generate a random sample of size 1000 from the Beta(3,2) distribution. </span>
a &lt;-<span class="st"> </span><span class="dv">3</span>; b &lt;-<span class="st"> </span><span class="dv">2</span>
c &lt;-<span class="st"> </span><span class="dv">12</span>
t &lt;-<span class="st"> </span><span class="kw">rBeta</span>(<span class="dv">1000</span>,<span class="dv">3</span>,<span class="dv">2</span>)       <span class="co">#sample data</span>
t
<span class="kw">hist</span>(t, <span class="dt">prob =</span> <span class="ot">TRUE</span>, <span class="dt">main =</span> <span class="kw">bquote</span>(<span class="kw">f</span>(x)<span class="op">==</span><span class="dv">12</span><span class="op">*</span>x<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x))) <span class="co">#density histogram of sample)</span>

y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, .<span class="dv">01</span>)
<span class="kw">lines</span>(y,c<span class="op">*</span>y<span class="op">^</span>(a<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>y)<span class="op">^</span>(b<span class="op">-</span><span class="dv">1</span>)) <span class="co"># density curve</span></code></pre></div>
<div id="states-1" class="section level4">
<h4>States</h4>
<p>As is required, I first establish the funtion rBeta(n,a,b) and n means sample size, a and b are the parameters of beta(a,b) distribution.</p>
<p>The pdf of beta(a,b) is <span class="math inline">\(f(x)=\frac{(a+b-1)!}{(a-1)!(b - 1)!}x^{(a - 1)}(1-x)^{(b - 1)}\)</span>.</p>
<p>There exists a constant <span class="math inline">\(c = \frac{(a+b-1)!}{(a-1)!(b-1)!}\)</span> such that <span class="math inline">\(f(x) &lt;= cg(x)\)</span> when <span class="math inline">\(g(x)=1I^x_{(0,1)}\)</span></p>
<p>P(acceptance) = <span class="math inline">\(\frac{1}{c}\)</span></p>
<p>After set the function, I generate a random sample of sample size 1000 from Beta(3,2) and plot the histogram.</p>
<p><br /><br /></p>
</div>
</div>
<div id="exercises-3.12.-pages-94" class="section level3">
<h3>Exercises 3.12. (pages 94)</h3>
<p>Simulate a continuous Exponential-Gamma mixture. Suppose that the rate parameter<span class="math inline">\(\Lambda\)</span> has <span class="math inline">\(Gamma(r, \beta)\)</span> distribution and Y has <span class="math inline">\(Exp(\Lambda)\)</span> distribution.</p>
<p>That is, <span class="math inline">\((Y |\Lambda = \lambda) \sim f_{Y} (y|\lambda) = \lambda{e^{-\lambda{y}}}\)</span>. Generate 1000 random observations from this mixture with r = 4 and <span class="math inline">\(\beta\)</span> = 2</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="co">#generate a Exponential-Gamma mixture</span>
    n &lt;-<span class="st"> </span><span class="dv">1000</span>
    r &lt;-<span class="st"> </span><span class="dv">4</span>
    beta &lt;-<span class="st"> </span><span class="dv">2</span>
    lambda &lt;-<span class="st"> </span><span class="kw">rgamma</span>(n, r, beta) <span class="co">#lambda is random</span>

    <span class="co">#now supply the sample of lambda's as the exponential parameter</span>
    x &lt;-<span class="st"> </span><span class="kw">rexp</span>(n, lambda)        <span class="co">#the mixture</span>
    x</code></pre></div>
<div id="states-2" class="section level4">
<h4>States</h4>
<p>First, we generate 1000 random obeserations called lambda vector from <span class="math inline">\(Gamma(r, \beta)\)</span> distribution, and then we supply the sample of lambda’s as the exponential parameter.</p>
<p>That is the way to generate a random sample of size 1000 from this mixture with r = 4 and <span class="math inline">\(\beta\)</span> = 2</p>
</div>
</div>
</div>
<div id="rd-20180928" class="section level2">
<h2><font color="Teal">3rd 2018/09/28</font></h2>
<div id="question-1" class="section level3">
<h3>Question</h3>
<p>Write a function to compute a Monte Carlo estimate of the Beta(3, 3) cdf, and use the function to estimate F(x) for x = 0.1, 0.2,…, 0.9. Compare the estimates with the values returned by the pbeta function in R.</p>
</div>
<div id="answer" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong>Write a function called ‘MCbeta’ of computing a Monte Carlo estimate of the Beta(a, b) cdf, where Beta(a,b) cdf: <span class="math display">\[ F = \int_0^x\frac{\Gamma(a+b-1)}{\Gamma(a-1)\Gamma(b-1)}x^{(a-1)}(1-x)^{(b-1)} \]</span></p>
<p>In this function there are four parameters: a, b, n and x.</p>
<p>Consider the problem of estimating <span class="math inline">\(\theta = \int_0^x30x^2(1-x)^2\)</span>. Generate 9 random uniform sample(0,x) whose size are all 1000, in which x equals to 0.1, 0.2,…, 0.9.</p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong> Using Monte Carlo to estimate the cdf, and the estimated value = <span class="math inline">\(\frac{1}{1000}x^2(1-x)^2\)</span></p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong></p>
<p>Compare the estimates with the value F(x) computed (numerically) by the pbeta function with ratio.</p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">MCbeta &lt;-<span class="st"> </span><span class="cf">function</span>(a,b,n,x){
  cdf &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span> <span class="op">:</span><span class="kw">length</span>(x) ){
      u &lt;-<span class="st"> </span><span class="kw">runif</span>(n,<span class="dv">0</span>,x[i])
      g &lt;-<span class="st"> </span>x[i] <span class="op">*</span><span class="st"> </span><span class="kw">factorial</span>(a<span class="op">+</span>b<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span><span class="kw">factorial</span>(a<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span><span class="kw">factorial</span>(b<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="st"> </span>u <span class="op">^</span>(a<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>u) <span class="op">^</span>(b<span class="op">-</span><span class="dv">1</span>)
      cdf[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(g)   <span class="co">#estimated value</span>
    }
    Phi &lt;-<span class="st"> </span><span class="kw">pbeta</span>(x,a,b)   <span class="co">#beta(a,b)</span>
    ratio &lt;-<span class="st"> </span>cdf<span class="op">/</span>Phi
    <span class="kw">print</span>(<span class="kw">round</span>(<span class="kw">rbind</span>(x, cdf, Phi, ratio), <span class="dv">3</span>))
}


x &lt;-<span class="st"> </span><span class="kw">seq</span>(.<span class="dv">1</span>,<span class="fl">0.9</span>, <span class="dt">length=</span><span class="dv">9</span>)
<span class="kw">MCbeta</span>(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">1000</span>,x)</code></pre></div>
<p><strong>As is shown before, the ratio is very near to 1,i.e.,the cdf is closed to Phi.</strong></p>
</div>
<div id="question-2" class="section level3">
<h3>Question</h3>
<p>The Rayleigh density [156, (18.76)] is <span class="math inline">\(f(x) = \frac{x}{??^2} e^{-\frac{x^2}{2??^2}}, x ?? 0,??&gt; 0\)</span>. Implement a function to generate samples from a Rayleigh(<span class="math inline">\(\sigma\)</span>) distribution, using antithetic variables. What is the percent reduction in variance of <span class="math inline">\(\frac{X+X'}{2}\)</span> compared with <span class="math inline">\(\frac{X_1+X_2}{2}\)</span> for independent <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span>?</p>
</div>
<div id="answer-1" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong></p>
<p>If X is a continuous random variable with cdf <span class="math inline">\(F_X (x)\)</span>, here <span class="math display">\[F_X (x)=1-e^{\frac{x^2}{2\sigma^2}}\]</span> Then <span class="math inline">\(U = F_X(X) \sim Uniform(0, 1)\)</span></p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong> The variable U follows a uniform distribution along [0, 1], the first sample will be {u_1 , ?? , u_n}, where, for any given i, u_i is obtained from <span class="math inline">\(U(0, 1)\)</span>. The second sample is built from <span class="math inline">\(u_1 ?? , ?? ,u_n ??\)</span>, where, for any given i:<span class="math inline">\(u_i'=1-u_i\)</span></p>
<p>Then <span class="math inline">\(x = F ^{-1}_X (u)\)</span>, <span class="math inline">\(X = F^{-1}(U), X' = F^{-1}(U')\)</span>both have distribution F but are antithentic to each other <span class="math inline">\(F^{-1}\)</span> is a monotone function.</p>
<p>and <span class="math inline">\(X=\sqrt{-2\sigma^2}ln(1-U)\)</span></p>
<p>Furthermore, covariance is negative, allowing for initial variance reduction.</p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong></p>
<p>Get the mean value and repeat m times, then we get the variance and variance reduction.</p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Antith.sampling &lt;-<span class="st"> </span><span class="cf">function</span>(sigma, n, <span class="dt">antithetic =</span> <span class="ot">TRUE</span>){
  u &lt;-<span class="st"> </span><span class="kw">runif</span>(n<span class="op">/</span><span class="dv">2</span>) 
  <span class="cf">if</span> (antithetic){ 
    v &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>u
    a &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span>u))
    b &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span>v))
    variance &lt;-<span class="st"> </span>(<span class="kw">var</span>(a)<span class="op">+</span><span class="kw">var</span>(b)<span class="op">+</span><span class="dv">2</span><span class="op">*</span><span class="kw">cov</span>(a,b))<span class="op">/</span><span class="dv">4</span> <span class="co"># c(a,b) is the whole sample, n is the sample size)</span>
  }
  <span class="cf">else</span>{
    v &lt;-<span class="st"> </span><span class="kw">runif</span>(n<span class="op">/</span><span class="dv">2</span>)
    u &lt;-<span class="st"> </span><span class="kw">c</span>(u, v)
    a &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span>u)) <span class="co"># a is the whole sample, n is the sample size</span>
    variance &lt;-<span class="kw">var</span>(a)
  }
variance
}

var1 &lt;-<span class="st"> </span><span class="kw">Antith.sampling</span>(<span class="dv">2</span>,<span class="dv">1000</span>,<span class="dt">antithetic =</span> <span class="ot">FALSE</span>) <span class="co"># variance of independent random variables</span>
var2 &lt;-<span class="st"> </span><span class="kw">Antith.sampling</span>(<span class="dv">2</span>,<span class="dv">1000</span>,<span class="dt">antithetic =</span> <span class="ot">TRUE</span>) <span class="co"># var of antithentic variables</span>
ratio &lt;-<span class="st"> </span><span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(var1<span class="op">-</span>var2)<span class="op">/</span>var1   <span class="co">#the percent of reduction</span>
<span class="kw">print</span>(<span class="kw">c</span>(var1,var2,ratio))</code></pre></div>
<p><strong>We can conclude that the Antithetic Variables method improves the effeciency of variance reduction a lot.</strong></p>
</div>
<div id="question-3" class="section level3">
<h3>Question</h3>
<p>Find two importance functions <span class="math inline">\(f1\)</span> and <span class="math inline">\(f2\)</span> that are supported on <span class="math inline">\((1, \infty)\)</span> and are close to</p>
<p><span class="math display">\[g(x) = \frac{x^2}{\sqrt{2??}} e^{-x^2/2}, x&gt; 1\]</span> Which of your two importance functions should produce the smaller variance in estimating<span class="math display">\[\int_1^\infty\frac{x^2}{\sqrt{2\pi}} e^{-x2/2}dx\]</span>by importance sampling? Explain.</p>
</div>
<div id="answer-2" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step</em></strong> Consider the density <span class="math inline">\(g(x)\)</span> and plot it, we choose several ??<span class="math inline">\(f(\dot)\)</span> which is close to <span class="math inline">\(g(x)\)</span></p>
<p>So, I choose <span class="math display">\[f_1(x) = e^{-x}, x \in (1,\infty)\]</span> and <span class="math display">\[f_2(x) = \frac{1}{x^2}, x \in (1,\infty)\]</span></p>
<p><bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>,<span class="dv">10</span>,<span class="fl">0.02</span>)
y &lt;-<span class="st"> </span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span><span class="st"> </span><span class="kw">exp</span>((<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))
y1 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x)
y2 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(x<span class="op">^</span><span class="dv">2</span>)

gs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">expression</span>(<span class="kw">g</span>(x)<span class="op">==</span>e<span class="op">^</span>{<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>}<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)),<span class="kw">expression</span>(f[<span class="dv">1</span>](x)<span class="op">==</span><span class="dv">1</span><span class="op">/</span>(x<span class="op">^</span><span class="dv">2</span>)),<span class="kw">expression</span>(f[<span class="dv">2</span>](x)<span class="op">==</span>x<span class="op">*</span>e<span class="op">^</span>{(<span class="dv">1</span><span class="op">-</span>x<span class="op">^</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">4</span>}<span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)))
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
    <span class="co">#figure (a)</span>
    <span class="kw">plot</span>(x, y, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="fl">0.5</span>),<span class="dt">main=</span><span class="st">'density function'</span>)
    <span class="kw">lines</span>(x, y1, <span class="dt">lty =</span> <span class="dv">2</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
    <span class="kw">lines</span>(x, y2, <span class="dt">lty =</span> <span class="dv">3</span>,<span class="dt">col=</span><span class="st">&quot;blue&quot;</span>)
    <span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">legend =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">2</span>,
           <span class="dt">lty =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,<span class="dt">inset =</span> <span class="fl">0.02</span>,<span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;black&quot;</span>,<span class="st">&quot;red&quot;</span>,<span class="st">&quot;blue&quot;</span>))

    <span class="co">#figure (b)</span>
   <span class="kw">plot</span>(x, y<span class="op">/</span>y1,  <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>,<span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">2</span>),<span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>,<span class="dt">lty =</span> <span class="dv">2</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>,<span class="dt">main =</span> <span class="st">'ratios'</span>)
    <span class="kw">lines</span>(x, y<span class="op">/</span>y2, <span class="dt">lty =</span> <span class="dv">3</span>,<span class="dt">col=</span><span class="st">&quot;blue&quot;</span>)
    <span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">legend =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,
           <span class="dt">lty =</span> <span class="dv">2</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">inset =</span> <span class="fl">0.02</span>,<span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;red&quot;</span>,<span class="st">&quot;blue&quot;</span>))</code></pre></div>
<p><strong>The function that corresponds to the most nearly constant ratio g(x)/f(x) appears to be <span class="math inline">\(f_2\)</span>, which is clear in figure.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {x<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span>(x<span class="op">&gt;</span><span class="dv">1</span>)}
m &lt;-<span class="st"> </span><span class="dv">10000</span>   
theta.hat &lt;-<span class="st"> </span>se &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">2</span>)

x &lt;-<span class="st"> </span><span class="kw">rexp</span>(m, <span class="dv">1</span>)   <span class="co">#using f1</span>
fg &lt;-<span class="st"> </span><span class="kw">g</span>(x) <span class="op">/</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x)
theta.hat[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(fg)
se[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">sd</span>(fg)

u &lt;-<span class="st"> </span><span class="kw">runif</span>(m) 
x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>u) <span class="co">#using f2</span>
fg &lt;-<span class="st"> </span><span class="kw">g</span>(x)<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span>
theta.hat[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(fg)
se[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">sd</span>(fg)           
<span class="kw">rbind</span>(theta.hat,se)</code></pre></div>
<p><strong>Same to the conclusion before, <span class="math inline">\(f_2\)</span> is better for its smaller variance.</strong></p>
</div>
<div id="question-4" class="section level3">
<h3>Question</h3>
<p>Obtain a Monte Carlo estimate of<span class="math inline">\(\int_1^\infty\frac{x^2}{\sqrt{2??}} e^{-x2/2}dx\)</span>by importance sampling</p>
</div>
<div id="answer-3" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> (5.13 Cont.), we choose <span class="math inline">\(f(x)=\frac{1}{x^2},x \in (1,+\infty)\)</span>as the importance function of <span class="math inline">\(g(x)=\frac{x^2}{\sqrt{2\pi}} e^{-x2/2},x\in(1,+\infty)\)</span> <bra></bra></p>
<p><strong><em>step2</em></strong> <span class="math display">\[\int_1^{\infty}\frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}dx=E(g(x)/f(x))\]</span> <bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {x<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span>(x<span class="op">&gt;</span><span class="dv">1</span>)}
m &lt;-<span class="st"> </span><span class="fl">1e4</span>                 
u &lt;-<span class="st"> </span><span class="kw">runif</span>(m) 
x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>u) <span class="co">#using f2</span>
fg &lt;-<span class="st"> </span><span class="kw">g</span>(x)<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span>
theta.hat &lt;-<span class="st"> </span><span class="kw">mean</span>(fg)
<span class="kw">print</span>(theta.hat)
theta &lt;-<span class="st"> </span><span class="kw">integrate</span>(g,<span class="dv">1</span>,<span class="ot">Inf</span>)
theta</code></pre></div>
<p><strong>Using integrate function to compute the theorial value,he estimate value is quite near to it.</strong></p>
</div>
</div>
<div id="th-20181013" class="section level2">
<h2><font color="Teal">4th 2018/10/13</font></h2>
<div id="question-5" class="section level3">
<h3>Question</h3>
<p>Let X be a non-negative random variable with <span class="math inline">\(?? = E[X] &lt; \infty\)</span>. For a random sample <span class="math inline">\(x_1,...,x_n\)</span> from the distribution of X, the Gini ratio is defined by<span class="math display">\[G = \frac{1}{2n\mu^2}\Sigma_i\Sigma_j|x_i-x_j|\]</span> The Gini ratio is applied in economics to measure inequality in income distribution. Note that G can be written in terms of the order statistics <span class="math inline">\(x(i)\)</span> as <span class="math display">\[G = \frac{1}{n\mu^2}\Sigma_1^n(2i - n - 1)x(i).\]</span> If the mean is unknown, let <span class="math inline">\(\hat{G}\)</span> be the statistic <span class="math inline">\(G\)</span> with <span class="math inline">\(\mu\)</span> replaced by <span class="math inline">\(\overline{x}\)</span>. Estimate by simulation the mean, median and deciles of <span class="math inline">\(\hat{G}\)</span> if <span class="math inline">\(X\)</span> is standard lognormal. Repeat the procedure for the uniform distribution and Bernoulli(0.1). Also construct density histograms of the replicates in each case.</p>
</div>
<div id="answer-4" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong></p>
<p><bra></bra> (a) Generate <span class="math inline">\(x_1^{(j)} ,...,x_n^{(j)} , iid\)</span> from the distribution of X.</p>
<p><bra></bra> (b) Sort <span class="math inline">\(x_1^{(j)} ,...,x_n^{(j)}\)</span>in increasing order, to obtain <span class="math inline">\(x_1^{(j)} \leq...\leq x_n^{(j)}\)</span></p>
<p><bra></bra> (c) Compute <span class="math display">\[\hat{G^{(j)}} = \frac{1}{n\overline{x^{(j)}}^2}\Sigma_1^n(2i - n - 1)x_{(i)}\]</span></p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong> Compute <span class="math inline">\(Media (G)=G^{m/2}\)</span> Compute deciles <span class="math inline">\(Deciles(G)=G^{im/10},i=1,...10.\)</span></p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong> Repeat the code and replacing the x from uniform distribution and Bernoulli(0.1)</p>
<p><strong><em>step4</em></strong> Plot the histgram.</p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">1000</span>
Gini &lt;-<span class="st"> </span><span class="cf">function</span>(m,n){
  G_hat1&lt;-G_hat2&lt;-G_hat3 &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
  
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
    x1 &lt;-<span class="st"> </span><span class="kw">rlnorm</span>(n)
    x2 &lt;-<span class="st"> </span><span class="kw">runif</span>(n)
    x3 &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n,<span class="dt">size=</span><span class="dv">1</span>,<span class="dt">prob=</span><span class="fl">0.1</span>)
    u1 &lt;-<span class="st"> </span><span class="kw">mean</span>(x1);u2 &lt;-<span class="st"> </span><span class="kw">mean</span>(x2);u3 &lt;-<span class="st"> </span><span class="kw">mean</span>(x3)
    x1sort &lt;-<span class="st"> </span><span class="kw">sort</span>(x1);x2sort &lt;-<span class="st"> </span><span class="kw">sort</span>(x2);x3sort &lt;-<span class="st"> </span><span class="kw">sort</span>(x3)

    g1&lt;-g2&lt;-g3 &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
      g1[i] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>i<span class="op">-</span>m<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x1sort[i]
      g2[i] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>i<span class="op">-</span>m<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x2sort[i]
      g3[i] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>i<span class="op">-</span>m<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x3sort[i]
    }
    G_hat1[j] &lt;-<span class="st"> </span><span class="kw">sum</span>(g1)<span class="op">/</span>m<span class="op">^</span><span class="dv">2</span><span class="op">/</span>u1
    G_hat2[j] &lt;-<span class="st"> </span><span class="kw">sum</span>(g2)<span class="op">/</span>m<span class="op">^</span><span class="dv">2</span><span class="op">/</span>u2
    G_hat3[j] &lt;-<span class="st"> </span><span class="kw">sum</span>(g3)<span class="op">/</span>m<span class="op">^</span><span class="dv">2</span><span class="op">/</span>u3
  }
  
  <span class="kw">print</span>(<span class="kw">c</span>(<span class="kw">mean</span>(G_hat1),<span class="kw">median</span>(G_hat1)))
  <span class="kw">print</span>(<span class="kw">quantile</span>(G_hat1,<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.1</span>)))
  <span class="kw">hist</span>(G_hat1,<span class="dt">prob=</span><span class="ot">TRUE</span>,<span class="dt">main =</span> <span class="st">&quot;X from lognorm distribution&quot;</span>)
  
  <span class="kw">print</span>(<span class="kw">c</span>(<span class="kw">mean</span>(G_hat2),<span class="kw">median</span>(G_hat2)))
  <span class="kw">print</span>(<span class="kw">quantile</span>(G_hat2,<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.1</span>)))
  <span class="kw">hist</span>(G_hat2,<span class="dt">prob=</span><span class="ot">TRUE</span>,<span class="dt">main =</span> <span class="st">&quot;X from uniform distribution&quot;</span>)
   
  <span class="kw">print</span>(<span class="kw">c</span>(<span class="kw">mean</span>(G_hat3),<span class="kw">median</span>(G_hat3)))
  <span class="kw">print</span>(<span class="kw">quantile</span>(G_hat3,<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.1</span>)))
  <span class="kw">hist</span>(G_hat3,<span class="dt">prob=</span><span class="ot">TRUE</span>,<span class="dt">main =</span> <span class="st">&quot;X from Bionomial(0.1) distribution&quot;</span>)
}

<span class="kw">Gini</span>(m,n)</code></pre></div>
<p><strong>As is shown before, the answer is totally different because X comes from diffferent populations.The Gini ratio measures the inequality among values of a frequency distribution (for example, levels of income). The larger the gini ratio, the higher the inequality. So when X comes from uniform, and G seems to be the lowest and when X comes from Bonulli distribution, G seems to be the highest. </strong></p>
</div>
<div id="question-6" class="section level3">
<h3>Question</h3>
<p>Construct an approximate 95% confidence interval for the Gini ratio <span class="math inline">\(Y = E[G]\)</span> if X is lognormal with unknown parameters. Assess the coverage rate of the estimation procedure with a Monte Carlo experiment.</p>
</div>
<div id="answer-5" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> Generate the replicates <span class="math inline">\(G(j), j = 1 ...,m\)</span> by repeating:</p>
<p><bra></bra> (a) Generate <span class="math inline">\(x_1^{(j)} ,...,x_n^{(j)} , iid\)</span> from the distribution of X.</p>
<p><bra></bra> (b) Sort <span class="math inline">\(x_1^{(j)} ,...,x_n^{(j)}\)</span>in increasing order, to obtain <span class="math inline">\(x_1^{(j)} \leq...\leq x_n^{(j)}\)</span></p>
<p><bra></bra> (c) Compute <span class="math display">\[\hat{G^{(j)}} = \frac{1}{n\overline{x^{(j)}}^2}\Sigma_1^n(2i - n - 1)x_{(i)}\]</span></p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong></p>
<p>According to the big sample properties, I compute the approximate 95% CI with the function Gini(m,n,a,b,alpha).m is the sample size of X,X comes from lognorm distribution, n is the sample number and a,b is the unknown parameters of lognorm distribution.The output is <span class="math inline">\((1-\alpha ) 100\%\)</span> confidence interval.</p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong> Assess the coverage rate with MC method.</p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">GCI &lt;-<span class="st"> </span><span class="cf">function</span>(m,n,a,b,alpha){
  G &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
    <span class="co"># function to calculate Gini with Normal distribution.</span>
    Gi &lt;-<span class="st"> </span><span class="cf">function</span>(n,a,b){
      y &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
      y &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rnorm</span>(n)) <span class="co"># x=exp(y) ~ln(0,1)</span>
      mu &lt;-<span class="st"> </span><span class="kw">exp</span>(a<span class="op">+</span>b<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>) <span class="co"># mu of X</span>
      Gini &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>mu <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>((<span class="dv">2</span><span class="op">*</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>n)<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">exp</span>(y))
      <span class="kw">return</span>(Gini)
      }
    G[i]&lt;-<span class="kw">Gi</span>(n,a,b)
    }
  LCL &lt;-<span class="st"> </span><span class="kw">quantile</span>(G,alpha<span class="op">/</span><span class="dv">2</span>)
  UCL &lt;-<span class="st"> </span><span class="kw">quantile</span>(G,<span class="dv">1</span><span class="op">-</span>alpha<span class="op">/</span><span class="dv">2</span>)
  CI &lt;-<span class="st"> </span><span class="kw">c</span>(LCL,UCL)
  count &lt;-<span class="kw">sum</span>(G <span class="op">&lt;=</span><span class="st"> </span>UCL)<span class="op">-</span><span class="kw">sum</span>(G <span class="op">&lt;</span><span class="st"> </span>LCL)
  coverage &lt;-<span class="st"> </span>count<span class="op">/</span>n <span class="co">#coverage rate</span>
  <span class="kw">return</span>(<span class="kw">c</span>(CI,coverage))
  }
<span class="kw">GCI</span>(<span class="dv">1000</span>,<span class="dv">1000</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.1</span>)</code></pre></div>
<p><strong>The output shows the CI and coverage rate.</strong></p>
</div>
<div id="question-7" class="section level3">
<h3>Question</h3>
<p>Tests for association based on Pearson product moment correlation <span class="math inline">\(\rho\)</span>, Spearman??s rank correlation coefficient <span class="math inline">\(\rho_s\)</span>, or Kendall??s coefficient <span class="math inline">\(\tau\)</span>, are implemented in <strong>cor.test</strong>. Show (empirically) that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> or <span class="math inline">\(\tau\)</span> are less powerful than the correlation test when the sampled distribution is bivariate normal. Find an example of an alternative (a bivariate distribution <span class="math inline">\((X, Y)\)</span> such that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are dependent) such that at least one of the nonparametric tests have better empirical power than the correlation test against this alternative.</p>
</div>
<div id="answer-6" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> first, we conduct a convariance matrix for independent variables. then, we compute the power and compare them.</p>
<p><bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
powers &lt;-<span class="st"> </span><span class="cf">function</span>(N,alpha,mu,sigma){
  p1&lt;-p2&lt;-p3&lt;-<span class="kw">numeric</span>(N)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
  bvn&lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(N, <span class="dt">mu =</span> mu, <span class="dt">Sigma =</span> sigma ) <span class="co"># mvrnorm function, independent</span>
  x&lt;-bvn[,<span class="dv">1</span>];y&lt;-bvn[,<span class="dv">2</span>]
  p1[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;spearman&quot;</span>)<span class="op">$</span>p.value
  p2[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;kendall&quot;</span>)<span class="op">$</span>p.value
  p3[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;pearson&quot;</span>)<span class="op">$</span>p.value
  }
power&lt;-<span class="kw">c</span>(<span class="kw">mean</span>(p1<span class="op">&lt;=</span>alpha),<span class="kw">mean</span>(p2<span class="op">&lt;=</span>alpha),<span class="kw">mean</span>(p3<span class="op">&lt;=</span>alpha))
<span class="kw">return</span>(power)
}
<span class="kw">set.seed</span>(<span class="dv">123</span>)
N &lt;-<span class="st"> </span><span class="dv">500</span> <span class="co"># Number of random samples</span>
alpha&lt;-<span class="fl">0.05</span>
<span class="co"># Target parameters for univariate normal distributions</span>
rho &lt;-<span class="st"> </span><span class="dv">0</span>
mu1 &lt;-<span class="st"> </span><span class="dv">0</span>; s1 &lt;-<span class="st"> </span><span class="dv">1</span>
mu2 &lt;-<span class="st"> </span><span class="dv">1</span>; s2 &lt;-<span class="st"> </span><span class="dv">4</span>
<span class="co"># Parameters for bivariate normal distribution</span>
mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu1,mu2) <span class="co"># Mean </span>
sigma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(s1<span class="op">^</span><span class="dv">2</span>, s1<span class="op">*</span>s2<span class="op">*</span>rho, s1<span class="op">*</span>s2<span class="op">*</span>rho, s2<span class="op">^</span><span class="dv">2</span>),<span class="dv">2</span>,<span class="dv">2</span>) <span class="co"># Covariance matrix</span>
<span class="kw">powers</span>(N,alpha,mu,sigma)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
powers &lt;-<span class="st"> </span><span class="cf">function</span>(N,alpha,mu,sigma){
  p1&lt;-p2&lt;-p3&lt;-<span class="kw">numeric</span>(N)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
  bvn&lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(N, <span class="dt">mu =</span> mu, <span class="dt">Sigma =</span> sigma ) <span class="co"># mvrnorm function, independent</span>
  x&lt;-bvn[,<span class="dv">1</span>];y&lt;-bvn[,<span class="dv">2</span>]
  p1[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;spearman&quot;</span>)<span class="op">$</span>p.value
  p2[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;kendall&quot;</span>)<span class="op">$</span>p.value
  p3[i]&lt;-<span class="kw">cor.test</span>(x,y,<span class="dt">method=</span><span class="st">&quot;pearson&quot;</span>)<span class="op">$</span>p.value
  }
power&lt;-<span class="kw">c</span>(<span class="kw">mean</span>(p1<span class="op">&lt;=</span>alpha),<span class="kw">mean</span>(p2<span class="op">&lt;=</span>alpha),<span class="kw">mean</span>(p3<span class="op">&lt;=</span>alpha))
<span class="kw">print</span>(<span class="kw">round</span>(power),<span class="dv">3</span>)
}
N &lt;-<span class="st"> </span><span class="dv">500</span> <span class="co"># Number of random samples</span>
alpha&lt;-<span class="fl">0.05</span>
<span class="co"># Target parameters for univariate normal distributions</span>
rho &lt;-<span class="st"> </span>.<span class="dv">6</span>
mu1 &lt;-<span class="st"> </span><span class="dv">0</span>; s1 &lt;-<span class="st"> </span><span class="dv">1</span>
mu2 &lt;-<span class="st"> </span><span class="dv">1</span>; s2 &lt;-<span class="st"> </span><span class="dv">4</span>
<span class="co"># Parameters for bivariate normal distribution</span>
mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu1,mu2) <span class="co"># Mean </span>
sigma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(s1<span class="op">^</span><span class="dv">2</span>, s1<span class="op">*</span>s2<span class="op">*</span>rho, s1<span class="op">*</span>s2<span class="op">*</span>rho, s2<span class="op">^</span><span class="dv">2</span>),<span class="dv">2</span>,<span class="dv">2</span>) <span class="co"># Covariance matrix</span>
<span class="kw">powers</span>(N,alpha,mu,sigma)</code></pre></div>
<p><strong>We can find that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> or <span class="math inline">\(\tau\)</span> are less powerful than the correlation test when the sampled distribution is bivariate normal. And when changing the <span class="math inline">\(\rho\)</span> into 0.6, the power is different.</strong> The question is :</p>
<ol style="list-style-type: decimal">
<li><p>Let <span class="math inline">\(X\)</span> be a non-negative random variable with <span class="math inline">\(\mu = E[X] &lt; ??\)</span>. For a random sample <span class="math inline">\(x_1\)</span> ,…,<span class="math inline">\(x_n\)</span> from the distribution of X, the Gini ratio is defined by <span class="math display">\[{G}=\frac{1}{2n^2\mu}\sum_{j=1}^n \sum_{i=1}^n |x_i-x_j|\]</span> The Gini ratio is applied in economics to measure inequality in income distribution (see e.g. [163]). Note that G can be written in terms of the order statistics <span class="math inline">\(x_(i)\)</span> as <span class="math display">\[{G}=\frac{1}{n^2\mu}\sum_{i=1}^n (2i-n-1)x_{(i)}\]</span> If the mean is unknown, let <span class="math inline">\(\hat{G}\)</span> be the statistic <span class="math inline">\(G\)</span> with <span class="math inline">\(\mu\)</span> replaced by <span class="math inline">\(\bar{x}\)</span>. Estimate by simulation the mean, median and deciles of <span class="math inline">\(\hat{G}\)</span> if <span class="math inline">\(X\)</span> is standard lognormal.Repeat the procedure for the uniform distribution and Bernoulli(0.1). Also construct density histograms of the replicates in each case.</p></li>
<li><p>Construct an approximate 95% confidence interval for the Gini ratio y = E[G] if X is lognormal with unknown parameters. Assess the coverage rate of the estimation procedure with a Monte Carlo experiment.</p></li>
<li><p>Tests for association based on Pearson product moment correlation <span class="math inline">\(\rho\)</span>, Spear-mans rank correlation coefficient <span class="math inline">\(\rho_s\)</span> , or Kendalls coefficient <span class="math inline">\(\tau\)</span>, are implemented in cor.test. Show (empirically) that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> or <span class="math inline">\(\tau\)</span> are less powerful than the correlation test when the sampled distribution is bivariate normal. Find an example of an alternative (a bivariate distribution <span class="math inline">\((X,Y)\)</span> such that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are dependent) such that at least one of the nonparametric tests have better empirical power than the correlation test against this alternative.</p></li>
</ol>
<p>The answer code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#The answer of first question:</span>
m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">20</span>
g &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
medians  &lt;-<span class="st"> </span>means &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">3</span>)
y &lt;-<span class="st"> </span>gini1 &lt;-<span class="st"> </span>gini2 &lt;-<span class="st"> </span>gini3 &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rlnorm</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini1[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">runif</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini2[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rbinom</span>(n,<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),<span class="kw">c</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>)))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini3[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))
<span class="kw">par</span>(<span class="dt">pin=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))
<span class="kw">hist</span>(gini1,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini1),<span class="dt">col =</span> <span class="st">&quot;red&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">hist</span>(gini2,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini2),<span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">hist</span>(gini3,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini3),<span class="dt">col =</span> <span class="st">&quot;green&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)

medians[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini1)
medians[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini2)
medians[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini3)
medians

quantiles1 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini1,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles1

quantiles2 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini2,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles2

quantiles3 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini3,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles3

means[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini1)
means[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini2)
means[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini3)
means


<span class="co">#The answer of second question:</span>
m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">20</span>
gini &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)

<span class="co">#Get A series of gini ratios genarating from a lognormal distribution</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rlnorm</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="co">#get the lower confidence interval </span>
LCI&lt;-<span class="st"> </span><span class="kw">mean</span>(gini)<span class="op">-</span><span class="kw">sd</span>(gini)<span class="op">*</span><span class="kw">qt</span>(<span class="fl">0.975</span>,m<span class="op">-</span><span class="dv">1</span>)
<span class="co">#get the upper confidence interval </span>
UCI &lt;-<span class="st"> </span><span class="kw">mean</span>(gini)<span class="op">+</span><span class="kw">sd</span>(gini)<span class="op">*</span><span class="kw">qt</span>(<span class="fl">0.975</span>,m<span class="op">-</span><span class="dv">1</span>)
<span class="co">#get the confidence interval</span>
CI &lt;-<span class="st"> </span><span class="kw">c</span>(LCI,UCI)
<span class="kw">print</span>(CI)
<span class="co">#calculate the converage rte </span>
covrate&lt;-<span class="kw">sum</span>(<span class="kw">I</span>(gini<span class="op">&gt;</span>CI[<span class="dv">1</span>]<span class="op">&amp;</span>gini<span class="op">&lt;</span>CI[<span class="dv">2</span>]))<span class="op">/</span>m
<span class="kw">print</span>(covrate)


<span class="co">#The answer of third question:</span>
<span class="co">#We need load the MASS package</span>
<span class="kw">library</span>(MASS)
mean &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)                                           
sigma &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(<span class="dv">25</span>,<span class="dv">5</span>,                            
                    <span class="dv">5</span>, <span class="dv">25</span>),<span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">2</span>)
m &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co">#Calculate the power using pearson correlation test by setting the parameter method as pearson</span>
pearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata1 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata1[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata1[,<span class="dv">2</span>]
    peartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>)
    peartest<span class="op">$</span>p.value
} )
power1 &lt;-<span class="st"> </span><span class="kw">mean</span>(pearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power1

<span class="co">#Calculate the power using spearman correlation test by setting the parameter method as spearman</span>
spearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata2 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata2[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata2[,<span class="dv">2</span>]
    speartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>)
    speartest<span class="op">$</span>p.value
} )
power2 &lt;-<span class="st"> </span><span class="kw">mean</span>(spearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power2

<span class="co">#Calculate the power using kendall correlation test by setting the parameter method as kendall</span>
kenvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata3 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata3[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata3[,<span class="dv">2</span>]
    kentest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;kendall&quot;</span>)
    kentest<span class="op">$</span>p.value
} )
power3 &lt;-<span class="st"> </span><span class="kw">mean</span>(kenvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power3

R &lt;-<span class="st"> </span><span class="dv">1000</span>
m &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co">#Calculate the power using pearson correlation test by setting the parameter method as pearson</span>
pearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    peartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>)
    peartest<span class="op">$</span>p.value
} )
power1 &lt;-<span class="st"> </span><span class="kw">mean</span>(pearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power1

<span class="co">#Calculate the power using spearman correlation test by setting the parameter method as spearman</span>
spearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    speartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>)
    speartest<span class="op">$</span>p.value
} )
power2 &lt;-<span class="st"> </span><span class="kw">mean</span>(spearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power2

<span class="co">#Calculate the power using kendall correlation test by setting the parameter method as kendall</span>
kenvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    kentest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;kendall&quot;</span>)
    kentest<span class="op">$</span>p.value
} )
power3 &lt;-<span class="st"> </span><span class="kw">mean</span>(kenvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power3</code></pre></div>
</div>
</div>
<div id="th-20181102" class="section level2">
<h2><font color="Teal">5th 2018/11/02</font></h2>
<div id="question-8" class="section level3">
<h3>Question</h3>
<p>The law school data set law contains LSAT and GPA for 15 law schools.This data set is a random sample from the universe of 82 law schools in law82.</p>
<p>Compute a jackknife estimate of the bias and the standard error of the correlation statistic.</p>
</div>
<div id="answer-7" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong></p>
<p>Define the ith jackknife sample<span class="math inline">\(x_{(i)}\)</span> to be the subset of <span class="math inline">\(x\)</span> that leaves out the ith observation <span class="math inline">\(x_i\)</span>.</p>
<p>That is, <span class="math inline">\(x_{(i)} = (x_1,\ldots,x_{i-1}, x_{i+1},\ldots,x_n)\)</span>.</p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong></p>
<p><span class="math inline">\(\hat{\theta} = T_n(x)\)</span>,define the ith jackknife replicate <span class="math inline">\(\hat{\theta}_{(i)} = T_{n-1}(x_{(i)}), i = 1,\ldots,n\)</span>.</p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong></p>
<p><span class="math inline">\(bias=E(\hat{\theta}-\theta)\)</span>, <span class="math inline">\(\hat{bias}_{jack}=(n-1)E(\overline{\hat{\theta}^{\star}}-\hat{\theta})\)</span></p>
<p><span class="math inline">\(\hat{se}_{jack}=\sqrt{(n-1)/n \sum_{i=1}^n(\bar{\hat{\theta}^{\star}}-\hat{\theta}_{i})^2}\)</span></p>
<p>The Jackknife estimate of <span class="math inline">\(\theta\)</span> is <span class="math inline">\(\hat{\theta}_{jack}=\hat{\theta}-\hat{bias}_{jack}\)</span></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bootstrap)
x &lt;-<span class="st"> </span>law<span class="op">$</span>LSAT; y&lt;-law<span class="op">$</span>GPA
cor &lt;-<span class="st"> </span><span class="kw">cor</span>(x,y)
n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
cor_jack &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)  <span class="co">#storage of the resamples</span>

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n)
  cor_jack[i] &lt;-<span class="st"> </span><span class="kw">cor</span>(x[<span class="op">-</span>i],y[<span class="op">-</span>i]) 

bias.jack &lt;-<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(<span class="kw">mean</span>(cor_jack)<span class="op">-</span>cor)

se.jack &lt;-<span class="st"> </span><span class="kw">sqrt</span>((n<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>n<span class="op">*</span><span class="kw">sum</span>((cor_jack<span class="op">-</span><span class="kw">mean</span>(cor_jack)))<span class="op">^</span><span class="dv">2</span>)
<span class="kw">print</span>(<span class="kw">list</span>(<span class="dt">cor=</span> cor ,<span class="dt">est=</span>cor<span class="op">-</span>bias.jack, <span class="dt">bias =</span> bias.jack,<span class="dt">se =</span> se.jack, <span class="dt">cv =</span> bias.jack<span class="op">/</span>se.jack))</code></pre></div>
<p><strong>We can find that in the 15 jackknife repeats, <span class="math inline">\(\hat{bias}_{jack}\)</span> is very small and the estimated coefficient of variation is far lower than 0.25.</strong></p>
</div>
<div id="question-9" class="section level3">
<h3>Question</h3>
<p>Refer to the air-conditioning data set aircondit provided in the boot package. The 12 observations are the times in hours between failures of air conditioning equipment: 3, 5, 7, 18, 43, 85, 91, 98, 100, 130, 230, 487. Assume that the times between failures follow an exponential model Exp(<span class="math inline">\(\lambda\)</span>).</p>
<p>Compute 95% bootstrap confidence intervals for themean time between failures <span class="math inline">\(\frac{1}{\lambda}\)</span> by the standard normal, basic, percentile,and BCa methods. Compare the intervals and explain why they may differ.</p>
</div>
<div id="answer-8" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> <span class="math inline">\(\frac{1}{\lambda}\)</span>is the mean value, so we use the data to resample and compute the mean.</p>
<p><strong><em>step2</em></strong> Use bootstrap to estimate the bias and standard error of the estimate <span class="math inline">\(\frac{1}{\lambda}\)</span>.</p>
<p><strong><em>step3</em></strong> Use R function boot.ci{boot}: basic, normal, percentile and BCa.</p>
<p><bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Bootstrap</span>
<span class="kw">library</span>(boot)
<span class="kw">data</span>(aircondit,<span class="dt">package =</span> <span class="st">&quot;boot&quot;</span>)
air &lt;-<span class="st"> </span>aircondit<span class="op">$</span>hours
theta.hat &lt;-<span class="st"> </span><span class="kw">mean</span>(air)
<span class="co">#set up the bootstrap</span>
B &lt;-<span class="st"> </span><span class="dv">2000</span>            <span class="co">#number of replicates</span>
n &lt;-<span class="st"> </span><span class="kw">length</span>(air)      <span class="co">#sample size</span>
theta.b &lt;-<span class="st"> </span><span class="kw">numeric</span>(B)     <span class="co">#storage for replicates</span>

<span class="co">#bootstrap estimate of standard error of R</span>
<span class="cf">for</span> (b <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>B) {
  <span class="co">#randomly select the indices</span>
  i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>n, <span class="dt">size =</span> n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  dat &lt;-<span class="st"> </span>air[i]       <span class="co">#i is a vector of indices</span>
  theta.b[b] &lt;-<span class="st"> </span><span class="kw">mean</span>(dat)
}

bias.theta &lt;-<span class="st"> </span><span class="kw">mean</span>(theta.b <span class="op">-</span><span class="st"> </span>theta.hat)
se &lt;-<span class="st"> </span><span class="kw">sd</span>(theta.b)

<span class="kw">print</span>(<span class="kw">list</span>(<span class="dt">bias.b =</span> bias.theta,<span class="dt">se.b =</span> se))

theta.boot &lt;-<span class="st"> </span><span class="cf">function</span>(dat,ind) {
  <span class="co">#function to compute the statistic</span>
  <span class="kw">mean</span>(dat[ind])
}
boot.obj &lt;-<span class="st"> </span><span class="kw">boot</span>(air, <span class="dt">statistic =</span> theta.boot, <span class="dt">R =</span> <span class="dv">2000</span>)
<span class="kw">print</span>(boot.obj)</code></pre></div>
<p><strong>Here I use both of function I write and the boot function from package “boot” and get the value and bias and se of the bias.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">boot.ci</span>(boot.obj, <span class="dt">type=</span><span class="kw">c</span>(<span class="st">&quot;basic&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;perc&quot;</span>,<span class="st">&quot;bca&quot;</span>)))</code></pre></div>
<p><strong>As is shown the intervals differ a lot because of transformation respecting and different order accuracy.</strong></p>
<p>The BCa confidence intervals are transformation respecting and BCa intervals have second order accuracy. Transformation respecting means that if <span class="math inline">\((\hat{\theta}^*_{\alpha1}, \hat{\theta}^*_{\alpha2})\)</span> is a confidence interval for <span class="math inline">\(\theta\)</span>, and <span class="math inline">\(t(\theta)\)</span> is a transformation of the parameter <span class="math inline">\(\theta\)</span>, here <span class="math inline">\(\theta = \frac{1}{\lambda}\)</span>, then the corresponding interval for <span class="math inline">\(t(\theta)\)</span> is <span class="math inline">\((t(\hat{\theta}^*_{\alpha1}),t(\hat{\theta}^*_{\alpha2}))\)</span>. A confidence interval is first order accurate if the error tends to zero at rate <span class="math inline">\(1/\sqrt{n}\)</span> for sample size <span class="math inline">\(n\)</span>, and second order accurate if the error tends to zero at rate <span class="math inline">\(1/n\)</span>. The bootstrap percentile interval is transformation respecting but only first order accurate. The standard normal confidence interval is neither transformation respecting nor second order accurate.</p>
</div>
<div id="question-10" class="section level3">
<h3>Question</h3>
<p>Refer to Exercise 7.7. Obtain the jackknife estimates of bias and standard error of <span class="math inline">\(\hat{\theta}\)</span>.</p>
</div>
<div id="answer-9" class="section level3">
<h3>Answer</h3>
<p>We need to use eigen function to get the eigen values and get the jackknife estimates. Then use the method to obtain the jackknife estimates of bias and standard error of <span class="math inline">\(\hat{\theta}\)</span>: An unbiased estimate of the bias <span class="math inline">\(E(\hat\theta)-\theta_0\)</span> is <span class="math display">\[(n-1)(\bar{\hat\theta}_{(\cdot)}-\hat\theta)\]</span>. An unbiased estimate of <span class="math inline">\(se(\hat\theta)\)</span> is <span class="math display">\[ \sqrt{\frac{n-1}n\sum_{i=1}^n(\hat\theta_{(i)}-\bar{\hat\theta}_{(\cdot)})^2}\]</span></p>
<p><bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Jackknife</span>
<span class="co">#compute the jackknife replicates, leave-one-out estimates</span>
<span class="kw">library</span>(bootstrap)
<span class="kw">data</span>(scor,<span class="dt">package =</span> <span class="st">&quot;bootstrap&quot;</span>)
n &lt;-<span class="st"> </span><span class="kw">length</span>(scor)
theta.jack &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
dat &lt;-<span class="st"> </span><span class="kw">cbind</span>(scor<span class="op">$</span>mec, scor<span class="op">$</span>vec, scor<span class="op">$</span>alg, scor<span class="op">$</span>ana, scor<span class="op">$</span>sta)
sigma.hat &lt;-<span class="st"> </span><span class="kw">cov</span>(dat)
theta.hat &lt;-<span class="st"> </span><span class="kw">eigen</span>(sigma.hat)<span class="op">$</span>values[<span class="dv">1</span>]<span class="op">/</span><span class="kw">sum</span>(<span class="kw">eigen</span>(sigma.hat)<span class="op">$</span>values)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){
  sigma.jack &lt;-<span class="st"> </span><span class="kw">cov</span>(dat[<span class="op">-</span>i,])
  theta.jack[i] &lt;-<span class="st"> </span><span class="kw">eigen</span>(sigma.jack)<span class="op">$</span>values[<span class="dv">1</span>]<span class="op">/</span><span class="kw">sum</span>(<span class="kw">eigen</span>(sigma.jack)<span class="op">$</span>values)
}

<span class="co">#jackknife estimate of bias</span>
bias.jack &lt;-<span class="st"> </span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>(<span class="kw">mean</span>(theta.jack) <span class="op">-</span><span class="st"> </span>theta.hat) 

<span class="co">#Jackknife estimate of standard error</span>
se.j &lt;-<span class="st"> </span><span class="kw">sqrt</span>((n<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span><span class="kw">mean</span>((theta.jack <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(theta.jack))<span class="op">^</span><span class="dv">2</span>))

<span class="kw">print</span>(<span class="kw">list</span>(<span class="dt">bias.jack =</span> bias.jack,<span class="dt">se.jack =</span> se.j))</code></pre></div>
<p><strong>Numerical results show that the bias is small and the method is very accurate because the se is quite small.</strong></p>
</div>
<div id="question-11" class="section level3">
<h3>Question</h3>
<p>In Example 7.18, leave-one-out (n-fold) cross validation was used to select the best fitting model. Use leave-two-out cross validation to compare the models. ###Answer</p>
<p><bra></bra></p>
<p><strong><em>step1</em></strong></p>
<p>We need to delete two data from datasets on which interpolation is to be done and to search the optimal shape parameter.</p>
<p>For <span class="math inline">\(k,j = 1,\ldots,n\)</span>, let observation <span class="math inline">\((x_k, y_k),(x_j,y_j),k\neq j\)</span> be the test points and use the remaining observations to fit the model.</p>
<p>For each <span class="math inline">\(x_i, i= 1,\ldots,n\)</span>, it will be used as test points for n times.</p>
<p>Compute the predicted response <span class="math inline">\(\hat{y_{i,k}} = \hat{\beta}_0 +\hat{ \beta}_1x_{i,k}\)</span> for the test point.</p>
<p>Compute the prediction error <span class="math inline">\(e_{i,k} = y_{k} ??? \hat{y}_{i,k}\)</span>.</p>
<p><strong><em>step2</em></strong></p>
<p>Estimate the mean of the squared prediction errors <span class="math inline">\(\hat{\sigma_{\epsilon}}^2=\frac{1}{n(n-1)}\sum{e^2_{i,k}}\)</span></p>
<p><strong><em>step3</em></strong></p>
<p>Compare the calculation accuracy of the two methods.</p>
<p><bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    ptm &lt;-<span class="st"> </span><span class="kw">proc.time</span>()
    
    <span class="kw">library</span>(DAAG); <span class="kw">attach</span>(ironslag)
    n &lt;-<span class="st"> </span><span class="kw">length</span>(magnetic)   <span class="co">#in DAAG ironslag</span>
    e1 &lt;-<span class="st"> </span>e2 &lt;-<span class="st"> </span>e3 &lt;-<span class="st"> </span>e4 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,n,n)
<span class="co">#    yhat1 &lt;- yhat2 &lt;- yhat3 &lt;- yhat4 &lt;- matrix(0,n,n)</span>
 <span class="co">#   logyhat3 &lt;- logyhat4 &lt;- matrix(0,n,n)</span>
    
    
    <span class="co"># for n-fold cross validation</span>
    <span class="co"># fit models on leave-two-out samples</span>
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){
        <span class="cf">if</span> (j <span class="op">!=</span><span class="st"> </span>i){
          y &lt;-<span class="st"> </span>magnetic[<span class="kw">c</span>(<span class="op">-</span>i,<span class="op">-</span>j)]
          x &lt;-<span class="st"> </span>chemical[<span class="kw">c</span>(<span class="op">-</span>i,<span class="op">-</span>j)]
          
          J1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x)
          yhat1 &lt;-<span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[j]
          e1[i,j] &lt;-<span class="st"> </span>magnetic[j] <span class="op">-</span><span class="st"> </span>yhat1
          
          J2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(x<span class="op">^</span><span class="dv">2</span>))
          yhat2 &lt;-<span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[j] <span class="op">+</span>
<span class="st">            </span>J2<span class="op">$</span>coef[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>chemical[j]<span class="op">^</span><span class="dv">2</span>
          e2[i,j] &lt;-<span class="st"> </span>magnetic[j] <span class="op">-</span><span class="st"> </span>yhat2
          
          J3 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span>x)
          logyhat3 &lt;-<span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[j]
          yhat3 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat3)
          e3[i,j] &lt;-<span class="st"> </span>magnetic[j] <span class="op">-</span><span class="st"> </span>yhat3
          
          J4 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(x))
          logyhat4 &lt;-<span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(chemical[j])
          yhat4 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat4)
          e4[i,j] &lt;-<span class="st"> </span>magnetic[j]<span class="op">-</span><span class="st"> </span>yhat4
        }
      }
    }
    

ltocv &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sum</span>(e1<span class="op">^</span><span class="dv">2</span>), <span class="kw">sum</span>(e2<span class="op">^</span><span class="dv">2</span>), <span class="kw">sum</span>(e3<span class="op">^</span><span class="dv">2</span>),<span class="kw">sum</span>(e4<span class="op">^</span><span class="dv">2</span>))<span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))
ltocv.ptm &lt;-<span class="st"> </span><span class="kw">proc.time</span>() <span class="op">-</span><span class="st"> </span>ptm <span class="co"># same function with system.time(exp)</span>
<span class="kw">print</span>(<span class="kw">list</span>(<span class="st">&quot;timeconsuming_of_ltocv&quot;</span>=ltocv.ptm[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]))
ltocv</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">rbind</span>(loocv,ltocv))
<span class="kw">row.names</span>(a) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;loocv&quot;</span>,<span class="st">&quot;ltocv&quot;</span>)
<span class="kw">names</span>(a) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;L1&quot;</span>,<span class="st">&quot;L2&quot;</span>,<span class="st">&quot;L3&quot;</span>,<span class="st">&quot;L4&quot;</span>)
knitr<span class="op">::</span><span class="kw">kable</span>(a)</code></pre></div>
<p><strong>This table shows us the estimation of the mean of the squared prediction errors <span class="math inline">\(\hat{\sigma}_\epsilon^2\)</span> of the two method, and in the r code of leave-two-out method, yhat was caculated for two times.</strong></p>
<p><strong>According to the numberical result, the computation time of LTOCV increases from 0.26s to more than 10 seconds due to pair wises elections of data, but the the mean of the squared prediction errors did not decreases significantly.</strong></p>
<p><strong>The prediction error criterion of both methods shows that the quadratic model is best fit for the data. The fitted model is</strong></p>
<p><span class="math display">\[\hat{Y} = 24.49262 - 1.39334X + 0.05452X^2\]</span> <font> ## <font color="Teal">6th 2018/11/16</font></p>
</div>
<div id="question-12" class="section level3">
<h3>Question</h3>
<p>Implement the two-sample Cram??er-von Mises test for equal distributions as a permutation test. Apply the test to the data in Examples 8.1 and 8.2</p>
</div>
<div id="answer-10" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> Consider the null hypothesis:<span class="math display">\[H_0: F=G\]</span> Cram??er-von Mises statistic is <span class="math display">\[W_2=\frac{mn}{(m+n)^2}[\sum_1^n(F_n(x_i)-G_m(x_i))^2+\sum_1^m(F_n(y_j)-G_m(y_j))^2]\]</span> where <span class="math inline">\(F_n\)</span> is the ecdf of the sample <span class="math inline">\(x_1,\ldots,x_n\)</span> and <span class="math inline">\(G_m\)</span> is the ecdf of the sample <span class="math inline">\(y_1,\ldots,y_m\)</span>. Large values of <span class="math inline">\(W_2\)</span> support alternative <span class="math inline">\(F \neq G\)</span>. <bra></bra></p>
<p><strong><em>step2</em></strong> Let <span class="math inline">\(r_1,r_2,\ldots,r_n\)</span> be the ranks of the x’s in the combined sample, and let <span class="math inline">\(s_1,s_2,\ldots,s_m\)</span> be the ranks of the y’s in the combined sample. <span class="math display">\[T = \frac{nm}{n+m} \omega^2 = \frac{U}{nm(n+m)}-\frac{4mn - 1}{6N}\]</span> where U is defined as <span class="math display">\[U = n \sum_{i=1}^n(r_i-i)^2 + m\sum_{j=1}^m (s_j-j)^2\]</span> Note: the method can be found in wiki.</p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong> According to the statistic or p-value to decide whether the null hypothesis is rejected or not.</p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">attach</span>(chickwts)
x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">as.vector</span>(weight[feed <span class="op">==</span><span class="st"> &quot;soybean&quot;</span>]))
y &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">as.vector</span>(weight[feed <span class="op">==</span><span class="st"> &quot;linseed&quot;</span>]))
<span class="kw">detach</span>(chickwts)

n &lt;-<span class="st"> </span><span class="kw">length</span>(x) <span class="co">#sample1 size</span>
m &lt;-<span class="st"> </span><span class="kw">length</span>(y) <span class="co">#sample2 size</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(x, y)          <span class="co">#pooled sample</span>
N &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span>m
h &lt;-<span class="st"> </span><span class="kw">numeric</span>(N)
T &lt;-<span class="st"> </span>m<span class="op">*</span>n<span class="op">/</span>(m<span class="op">+</span>n)<span class="op">^</span><span class="dv">2</span>
R &lt;-<span class="st"> </span><span class="dv">999</span>              <span class="co">#number of replicates</span>
K &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>N
reps &lt;-<span class="st"> </span><span class="kw">numeric</span>(R)   <span class="co">#storage for replicates</span>
v.n &lt;-<span class="st"> </span>v1.n &lt;-<span class="st"> </span><span class="kw">numeric</span>(n); v.m &lt;-<span class="st"> </span>v1.m &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) v.n[i] &lt;-<span class="st"> </span>( x[i] <span class="op">-</span><span class="st"> </span>i )<span class="op">**</span><span class="dv">2</span>
<span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) v.m[j] &lt;-<span class="st"> </span>( y[j] <span class="op">-</span><span class="st"> </span>j )<span class="op">**</span><span class="dv">2</span>

reps0 &lt;-<span class="st"> </span>( (n <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(v.n) <span class="op">+</span><span class="st"> </span>m <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(v.m)) <span class="op">/</span><span class="st"> </span>(m <span class="op">*</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>N) ) <span class="op">-</span><span class="st">  </span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>m <span class="op">*</span><span class="st"> </span>n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>(<span class="dv">6</span> <span class="op">*</span><span class="st"> </span>N) 
<span class="co">#replicates</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>R) {
  <span class="co">#generate indices k for the first sample</span>
  k &lt;-<span class="st"> </span><span class="kw">sample</span>(K, <span class="dt">size =</span> n, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
  x1 &lt;-<span class="st"> </span>z[k]
  y1 &lt;-<span class="st"> </span>z[<span class="op">-</span>k]      <span class="co">#complement of x1</span>
  z1 &lt;-<span class="st"> </span><span class="kw">c</span>(x1,y1)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) { v1.n[i] &lt;-<span class="st"> </span>( x1[i] <span class="op">-</span><span class="st"> </span>i )<span class="op">**</span><span class="dv">2</span> }
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) { v1.m[j] &lt;-<span class="st"> </span>( y1[j] <span class="op">-</span><span class="st"> </span>j )<span class="op">**</span><span class="dv">2</span> }
  reps[k] &lt;-<span class="st"> </span>( (n <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(v1.n) <span class="op">+</span><span class="st"> </span>m <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(v1.m)) <span class="op">/</span><span class="st"> </span>(m <span class="op">*</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>N) ) <span class="op">-</span><span class="st"> </span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>m <span class="op">*</span><span class="st"> </span>n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>(<span class="dv">6</span> <span class="op">*</span><span class="st"> </span>N)
}
p &lt;-<span class="st"> </span><span class="kw">mean</span>( <span class="kw">c</span>(reps0, reps) <span class="op">&gt;=</span><span class="st"> </span>reps0 )
p</code></pre></div>
<pre><code>## [1] 0.024</code></pre>
<p><strong>According to the p-value, we reject <span class="math inline">\(H_0\)</span> significantly.</strong></p>
</div>
<div id="question-13" class="section level3">
<h3>Question</h3>
<ul>
<li><p>Design experiments for evaluating the performance of the NN, energy, and ball methods in various situations.</p>
<ul>
<li>Unequal variances and equal expectations</li>
<li>Unequal variances and unequal expectations</li>
<li>Non-normal distributions: t distribution with 1 df (heavy-tailed distribution), bimodel distribution (mixture of two normal distributions)</li>
<li>Unbalanced samples (say, 1 case versus 10 controls)</li>
<li>Note: The parameters should be choosen such that the powers are distinguishable (say, range from 0.3 to 0.9).</li>
</ul></li>
</ul>
</div>
<div id="answer-11" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><strong><em>step1</em></strong> In this simulation experiment, I will compare the empirical power of the third nearest neighbor test, the energy test and the ball test.</p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong></p>
<p>First, unequal variances and equal expectations <span class="math display">\[F_1=N_2(\mu = (0, 0)_2, \Sigma =  I_2), F_2 = N_2(?? = (0, 0)_2 , ?? = 2I_2) \]</span> Second,unequal variances and unequal expectations <span class="math display">\[F_1=N_2(\mu = (0, 0)_2, \Sigma =  I_2), F_2 = N_2(?? = (0, 1)_2 , ?? = 2I_2) \]</span> Third, non-normal distributions: t distribution with 1 df (heavy-tailed distribution), bimodel distribution (mixture of two normal distributions)</p>
<p><span class="math display">\[F_1=t_1, F_2 = N_1(0,1)*N_1(1,2) \]</span> And finally, unbalanced samples (say, 1 case versus 10 controls) <span class="math display">\[F_1=t_1,F_2 = N_2((0,0),I_2) \]</span> <bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(RANN)
<span class="kw">library</span>(energy)
<span class="kw">library</span>(Ball)
<span class="kw">library</span>(boot)
m &lt;-<span class="st"> </span><span class="dv">50</span>; k&lt;-<span class="dv">3</span>; p&lt;-<span class="dv">2</span>
n1 &lt;-<span class="st"> </span>n2 &lt;-<span class="st"> </span><span class="dv">15</span>;N =<span class="st"> </span><span class="kw">c</span>(n1,n2); R&lt;-<span class="dv">999</span>

Tn &lt;-<span class="st"> </span><span class="cf">function</span>(z, ix, sizes,k) {
  n1 &lt;-<span class="st"> </span>sizes[<span class="dv">1</span>]
  n2 &lt;-<span class="st"> </span>sizes[<span class="dv">2</span>]
  n &lt;-<span class="st"> </span>n1 <span class="op">+</span><span class="st"> </span>n2
  z &lt;-<span class="st"> </span>z[ix, ]
  o &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">NROW</span>(z))
  z &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">cbind</span>(z, o))
  NN &lt;-<span class="st"> </span><span class="kw">nn2</span>(z, <span class="dt">k=</span>k<span class="op">+</span><span class="dv">1</span>)  <span class="co">#uses package RANN</span>
  block1 &lt;-<span class="st"> </span>NN<span class="op">$</span>nn.idx[<span class="dv">1</span><span class="op">:</span>n1,<span class="op">-</span><span class="dv">1</span>]
  block2 &lt;-<span class="st"> </span>NN<span class="op">$</span>nn.idx[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span>n1),<span class="op">-</span><span class="dv">1</span>]
  i1 &lt;-<span class="st"> </span><span class="kw">sum</span>(block1 <span class="op">&lt;</span><span class="st"> </span>n1 <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>)
  i2 &lt;-<span class="st"> </span><span class="kw">sum</span>(block2 <span class="op">&gt;</span><span class="st"> </span>n1 <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>)
  <span class="kw">return</span>((i1 <span class="op">+</span><span class="st"> </span>i2) <span class="op">/</span><span class="st"> </span>(k <span class="op">*</span><span class="st"> </span>n))
}

eqdist.nn &lt;-<span class="st"> </span><span class="cf">function</span>(z,sizes,k){
  boot.obj &lt;-<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data=</span>z,<span class="dt">statistic=</span>Tn,<span class="dt">R=</span>R,
                   <span class="dt">sim =</span> <span class="st">&quot;permutation&quot;</span>, <span class="dt">sizes =</span> sizes,<span class="dt">k=</span>k)
  ts &lt;-<span class="st"> </span><span class="kw">c</span>(boot.obj<span class="op">$</span>t0,boot.obj<span class="op">$</span>t)
  p.value &lt;-<span class="st"> </span><span class="kw">mean</span>(ts<span class="op">&gt;=</span>ts[<span class="dv">1</span>])
  <span class="kw">list</span>(<span class="dt">statistic=</span>ts[<span class="dv">1</span>],<span class="dt">p.value=</span>p.value)
}
p.values &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">3</span>)

<span class="co">#Unequal variances and equal expectations</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span><span class="dv">2</span>),<span class="dt">ncol=</span><span class="dv">2</span>);
  y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>),<span class="dt">ncol=</span><span class="dv">2</span>);
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value  <span class="co">#NN</span>
  p.values[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value  <span class="co">#energy method</span>
  p.values[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span>R,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value  <span class="co">#ball method</span>
}
alpha &lt;-<span class="st"> </span><span class="fl">0.05</span>                        <span class="co">#confidence level </span>
pow &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow</code></pre></div>
<p><strong>These alternatives differ in variance only, and the empirical evidence summarized before suggests that ball method is most powerful.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Unequal variances and unequal expectations</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span><span class="dv">2</span>),<span class="dt">ncol=</span><span class="dv">2</span>);
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2,<span class="dv">0</span>,<span class="dv">2</span>),<span class="kw">rnorm</span>(n2,<span class="dv">1</span>,<span class="dv">2</span>));
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value  <span class="co">#NN</span>
  p.values[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value  <span class="co">#energy method</span>
  p.values[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span>R,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value  <span class="co">#ball method</span>
}
alpha &lt;-<span class="st"> </span><span class="fl">0.05</span>                        <span class="co">#confidence level </span>
pow &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow</code></pre></div>
<p><strong>The emperical power differs from 0.38 to 0.96 and the ball is also the best.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Non-normal distributions: t distribution with 1 df (heavy-tailed distribution), bimodel distribution (mixture of two normal distributions)</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n1<span class="op">*</span><span class="dv">2</span>,<span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2),<span class="kw">rnorm</span>(n2,<span class="dv">1</span>,<span class="dv">2</span>))
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value  <span class="co">#NN</span>
  p.values[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value  <span class="co">#energy method</span>
  p.values[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span>R,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value  <span class="co">#ball method</span>
}
alpha &lt;-<span class="st"> </span><span class="fl">0.05</span>                        <span class="co">#confidence level </span>
pow &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow</code></pre></div>
<p><strong>Differently the energy method displays best and the ball is also not bad.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Unbalanced samples (say, 1 case versus 10 controls)</span>
n1 &lt;-<span class="st"> </span><span class="dv">10</span>; n2 &lt;-<span class="st"> </span><span class="dv">100</span>; N =<span class="st"> </span><span class="kw">c</span>(n1,n2)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n1<span class="op">*</span><span class="dv">2</span>,<span class="dv">1</span>),<span class="dt">ncol=</span><span class="dv">2</span>);
  y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n2<span class="op">*</span><span class="dv">2</span>),<span class="dt">ncol=</span><span class="dv">2</span>);
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,<span class="dv">3</span>)<span class="op">$</span>p.value  <span class="co">#NN</span>
  p.values[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value  <span class="co">#energy method</span>
  p.values[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span>R,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value  <span class="co">#ball method</span>
}
alpha &lt;-<span class="st"> </span><span class="fl">0.05</span>                        <span class="co">#confidence level </span>
pow &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow</code></pre></div>
<p><strong>Unbalanced data shows that the energy is best and the NNtest follows.</strong></p>
</div>
<div id="question-14" class="section level3">
<h3>Question</h3>
<p>Use the Metropolis-Hastings sampler to generate random variables from a standard Cauchy distribution. Discard the first 1000 of the chain, and compare the deciles of the generated observations with the deciles of the standard Cauchy distribution (see qcauchy or qt with df=1). Recall that a <span class="math inline">\(Cauchy(\theta,\eta)\)</span> distribution has density function<span class="math display">\[f(x)=\frac{1}{\theta\pi(1+[(x-\eta)/\theta]^2)},-\infty &lt;x&lt;\infty,\theta &gt;0\]</span>.</p>
<p>The standard Cauchy has the <span class="math inline">\(Cauchy(\theta = 1, \eta = 0)\)</span> density. (Note that the standard Cauchy density is equal to the Student t density with one degree of freedom.) ###Answer</p>
<p><bra></bra></p>
<p><strong><em>step1</em></strong></p>
<p>Choose a proposal distribution <span class="math inline">\(g(??|X_t)\)</span>. Here I use Normal Distribution.</p>
<p><bra></bra></p>
<p><strong><em>step2</em></strong> Generate <span class="math inline">\(X_0\)</span> from a distribution normal distribution, and repeat.</p>
<p><bra></bra></p>
<p><strong><em>step3</em></strong></p>
<p>Plot and compare with the theorial value.</p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Cauchy distribution density function</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x, theta,eta) {
  <span class="kw">stopifnot</span>(theta <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)
  <span class="kw">return</span>(<span class="dv">1</span><span class="op">/</span>(theta<span class="op">*</span>pi<span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>((x<span class="op">-</span>eta)<span class="op">/</span>theta)<span class="op">^</span><span class="dv">2</span>)))
  }

m &lt;-<span class="st"> </span><span class="dv">10000</span>
theta &lt;-<span class="st"> </span><span class="dv">1</span>; eta &lt;-<span class="st"> </span><span class="dv">0</span>
x &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
x[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>) <span class="co">#proposal densty</span>
k &lt;-<span class="st"> </span><span class="dv">0</span>
u &lt;-<span class="st"> </span><span class="kw">runif</span>(m)

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>m) {
  xt &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
  y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dt">mean =</span>  xt)
  num &lt;-<span class="st"> </span><span class="kw">f</span>(y, theta, eta) <span class="op">*</span><span class="st"> </span><span class="kw">dnorm</span>(xt, <span class="dt">mean =</span> y)
  den &lt;-<span class="st"> </span><span class="kw">f</span>(xt, theta, eta) <span class="op">*</span><span class="st"> </span><span class="kw">dnorm</span>(y, <span class="dt">mean =</span> xt)
  <span class="cf">if</span> (u[i] <span class="op">&lt;=</span><span class="st"> </span>num<span class="op">/</span>den) x[i] &lt;-<span class="st"> </span>y <span class="cf">else</span> {
    x[i] &lt;-<span class="st"> </span>xt
    k &lt;-<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>     <span class="co">#y is rejected</span>
  }
}
<span class="kw">print</span>(k)</code></pre></div>
<p><strong>In this exercise, approximately 20% of the candidate points are rejected, so the chain is somewhat not bad, but can be better.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dv">1</span><span class="op">:</span>m, x, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;x&quot;</span>)

<span class="co">#discard the burnin sample</span>
b &lt;-<span class="st"> </span><span class="dv">1001</span>     
y &lt;-<span class="st"> </span>x[b<span class="op">:</span>m]
a &lt;-<span class="st"> </span><span class="kw">ppoints</span>(<span class="dv">100</span>)
Qc &lt;-<span class="st"> </span><span class="kw">qcauchy</span>(a)  <span class="co">#quantiles of Standard Cauchy</span>
Q &lt;-<span class="st"> </span><span class="kw">quantile</span>(x, a)

<span class="kw">qqplot</span>(Qc, Q, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>), <span class="dt">xlab=</span><span class="st">&quot;Standard Cauchy Quantiles&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Sample Quantiles&quot;</span>)

<span class="kw">hist</span>(y, <span class="dt">breaks=</span><span class="st">&quot;scott&quot;</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>, <span class="dt">freq=</span><span class="ot">FALSE</span>)
<span class="kw">lines</span>(Qc, <span class="kw">f</span>(Qc, <span class="dv">1</span>, <span class="dv">0</span>))</code></pre></div>
<p><strong>From the plot, it appears that the sample quantiles are in approximate agreement with the theoretical quantiles.</strong></p>
</div>
<div id="question-15" class="section level3">
<h3>Question</h3>
<p>Rao [220, Sec. 5g] presented an example on genetic linkage of 197 animals in four categories (also discussed in [67, 106, 171, 266]). The group sizes are 278 (125, 18, 20, 34). Assume that the probabilities of the corresponding multinomial distribution are<span class="math display">\[(\frac{1}{2}+\frac{\theta}{4},\frac{1-\theta}{4},\frac{1-\theta}{4},\frac{\theta}{4})\]</span>. Estimate the posterior distribution of ?? given the observed sample, using one of the methods in this chapter.</p>
</div>
<div id="answer-12" class="section level3">
<h3>Answer</h3>
<p><bra></bra></p>
<p><span class="math display">\[f(GS|\theta) = (\frac{2 + \theta}{4})^{gs_1}(\frac{1-\theta}{4})^{gs_2}(\frac{1-\theta}{4})^{gs_3}(\frac{\theta}{4})^{gs_4}=(\frac{2 + \theta}{4})^{gs_1}(\frac{1-\theta}{4})^{gs_2 + gs_3}(\frac{\theta}{4})^{gs_4}\]</span> gs is group size <bra></bra></p>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong>The code and the result is shown as below:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">125</span>,<span class="dv">18</span>,<span class="dv">20</span>,<span class="dv">34</span>)  <span class="co">#group size</span>
m &lt;-<span class="st"> </span><span class="dv">5000</span>
w &lt;-<span class="st"> </span>.<span class="dv">25</span> 
b &lt;-<span class="st"> </span><span class="dv">1001</span>
<span class="co">#the target density</span>
prob &lt;-<span class="st"> </span><span class="cf">function</span>(y, gs) {
  <span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">|</span><span class="st"> </span>y <span class="op">&gt;</span><span class="dv">1</span>)
    <span class="kw">return</span> (<span class="dv">0</span>)
  <span class="cf">else</span>
    <span class="kw">return</span>((<span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">+</span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">1</span>] <span class="op">*</span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">2</span>]<span class="op">*</span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">3</span>]<span class="op">*</span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">4</span>])
}

u &lt;-<span class="st"> </span><span class="kw">runif</span>(m)  <span class="co">#for accept/reject step</span>
v &lt;-<span class="st"> </span><span class="kw">runif</span>(m, <span class="op">-</span>w, w)  <span class="co">#proposal distribution</span>
x[<span class="dv">1</span>] &lt;-<span class="st"> </span>.<span class="dv">25</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>m) {
  y &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>v[i]
  <span class="cf">if</span> (u[i] <span class="op">&lt;=</span><span class="st"> </span><span class="kw">prob</span>(y, gs) <span class="op">/</span><span class="st"> </span><span class="kw">prob</span>(x[i<span class="op">-</span><span class="dv">1</span>], gs))
    x[i] &lt;-<span class="st"> </span>y 
  <span class="cf">else</span>
    x[i] &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
}  
theta.hat &lt;-<span class="st"> </span><span class="kw">mean</span>(x[b<span class="op">:</span>m])
theta.hat</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># compare</span>
gs.hat &lt;-<span class="st"> </span><span class="kw">sum</span>(gs) <span class="op">*</span><span class="st"> </span><span class="kw">c</span>((<span class="dv">2</span><span class="op">+</span>theta.hat)<span class="op">/</span><span class="dv">4</span>, (<span class="dv">1</span><span class="op">-</span>theta.hat)<span class="op">/</span><span class="dv">4</span>, (<span class="dv">1</span><span class="op">-</span>theta.hat)<span class="op">/</span><span class="dv">4</span>, theta.hat<span class="op">/</span><span class="dv">4</span>)
<span class="kw">round</span>(gs.hat)</code></pre></div>
<p><strong>So, theta.hat is near to the real value.</strong></p>
</div>
</div>
<div id="th-20181123" class="section level2">
<h2><font color="Teal">7th 2018/11/23</font></h2>
<div id="question-16" class="section level3">
<h3>Question</h3>
<p>Exercise 9.6 presented an example on genetic linkage of 197 animals in four categories. The group sizes are 278(125, 18, 20, 34). Assume that the probabilities of the corresponding multinomial distribution are<span class="math display">\[(\frac{1}{2}+\frac{\theta}{4},\frac{1-\theta}{4},\frac{1-\theta}{4},\frac{\theta}{4}).\]</span> Use the Gelman-Rubin method to monitor convergence of the chain, and run the chain until the chain has converged approximately to the target distribution according to <span class="math inline">\(\hat{R}\)</span> &lt; 1.2.</p>
</div>
<div id="answer-13" class="section level3">
<h3>Answer</h3>
<p><strong><em>step1</em></strong> The Gelman-Rubin method of monitoring convergence of a M-H chain is based on comparing the behavior of several generated chains with respect to the variance of one or more scalar summary statistics.</p>
<p><strong><em>step2</em></strong> The Gelman-Rubin statistic is the estimated potential scale reduction<span class="math inline">\(\sqrt{\hat{R}}=\sqrt{\frac{\hat{Var(\psi}}{W}}.\)</span></p>
<p><strong><em>step3</em></strong> The factor <span class="math inline">\(\hat{R}\)</span> decreases to 1 as the length of the chain tends to infinity, so <span class="math inline">\(\hat{R}\)</span> should be close to 1 if the chains have approximately converged to the target distribution. Here we choose 1.1 and 1.2.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">### Gelman-Rubin method of monitoring convergence

Gelman.Rubin &lt;-<span class="st"> </span><span class="cf">function</span>(psi) {
  <span class="co"># psi[i,j] is the statistic psi(X[i,1:j])</span>
  <span class="co"># for chain in i-th row of X</span>
  psi &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(psi)
  n &lt;-<span class="st"> </span><span class="kw">ncol</span>(psi)
  k &lt;-<span class="st"> </span><span class="kw">nrow</span>(psi)
  
  psi.means &lt;-<span class="st"> </span><span class="kw">rowMeans</span>(psi)     <span class="co">#row means</span>
  B &lt;-<span class="st"> </span>n <span class="op">*</span><span class="st"> </span><span class="kw">var</span>(psi.means)        <span class="co">#between variance est.</span>
  psi.w &lt;-<span class="st"> </span><span class="kw">apply</span>(psi, <span class="dv">1</span>, <span class="st">&quot;var&quot;</span>)  <span class="co">#within variances</span>
  W &lt;-<span class="st"> </span><span class="kw">mean</span>(psi.w)               <span class="co">#within est.</span>
  v.hat &lt;-<span class="st"> </span>W<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>n <span class="op">+</span><span class="st"> </span>(B<span class="op">/</span>n)     <span class="co">#upper variance est.</span>
  r.hat &lt;-<span class="st"> </span>v.hat <span class="op">/</span><span class="st"> </span>W             <span class="co">#G-R statistic</span>
  <span class="kw">return</span>(r.hat)
}

gs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">125</span>,<span class="dv">18</span>,<span class="dv">20</span>,<span class="dv">34</span>)  <span class="co">#group size</span>
<span class="co">#m &lt;- 5000</span>
<span class="co">#w &lt;- .25 </span>
b &lt;-<span class="st"> </span><span class="dv">1001</span>
<span class="co">#the target density</span>
prob &lt;-<span class="st"> </span><span class="cf">function</span>(y, gs) {
  <span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">|</span><span class="st"> </span>y <span class="op">&gt;</span><span class="dv">1</span>)
    <span class="kw">return</span> (<span class="dv">0</span>)
  <span class="cf">else</span>
    <span class="kw">return</span>((<span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">+</span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">1</span>] <span class="op">*</span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">2</span>]<span class="op">*</span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">3</span>]<span class="op">*</span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>gs[<span class="dv">4</span>])
}

chain &lt;-<span class="st"> </span><span class="cf">function</span>(w, N) {
  <span class="co">#generates a Metropolis chain for Normal(0,1)</span>
  <span class="co">#with Normal(X[t], sigma) proposal distribution</span>
  <span class="co">#and starting value X1</span>
  x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, N)
  u &lt;-<span class="st"> </span><span class="kw">runif</span>(N)  <span class="co">#for accept/reject step</span>
  v &lt;-<span class="st"> </span><span class="kw">runif</span>(N, <span class="op">-</span>w, w)  <span class="co">#proposal distribution</span>
  x[<span class="dv">1</span>] &lt;-<span class="st"> </span>w
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) {
    y &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>v[i]
    <span class="cf">if</span> (u[i] <span class="op">&lt;=</span><span class="st"> </span><span class="kw">prob</span>(y, gs) <span class="op">/</span><span class="st"> </span><span class="kw">prob</span>(x[i<span class="op">-</span><span class="dv">1</span>], gs))
      x[i] &lt;-<span class="st"> </span>y 
    <span class="cf">else</span>
      x[i] &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
  }
  <span class="kw">return</span>(x)
}

k &lt;-<span class="st"> </span><span class="dv">4</span>          <span class="co">#number of chains to generate</span>
n &lt;-<span class="st"> </span><span class="dv">15000</span>      <span class="co">#length of chains</span>
w &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.05</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.7</span>,<span class="fl">0.9</span>)

<span class="co">#generate the chains</span>
X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow=</span>k, <span class="dt">ncol=</span>n)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>k)
  X[i, ] &lt;-<span class="st"> </span><span class="kw">chain</span>(w[i], n)

<span class="co">#compute diagnostic statistics</span>
psi &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(X, <span class="dv">1</span>, cumsum))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(psi))
  psi[i,] &lt;-<span class="st"> </span>psi[i,] <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(psi))
<span class="kw">print</span>(<span class="kw">Gelman.Rubin</span>(psi))

<span class="co">#plot psi for the four chains</span>
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>k)
  <span class="kw">plot</span>(psi[i, (b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n], <span class="dt">type=</span><span class="st">&quot;l&quot;</span>,
       <span class="dt">xlab=</span>i, <span class="dt">ylab=</span><span class="kw">bquote</span>(psi))
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)) <span class="co">#restore default</span>

<span class="co">#plot the sequence of R-hat statistics</span>
rhat &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n)
<span class="cf">for</span> (j <span class="cf">in</span> (b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n)
  rhat[j] &lt;-<span class="st"> </span><span class="kw">Gelman.Rubin</span>(psi[,<span class="dv">1</span><span class="op">:</span>j])
<span class="kw">plot</span>(rhat[(b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n], <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>,<span class="dt">ylim =</span> <span class="kw">range</span>(<span class="dv">1</span>,<span class="fl">1.4</span>), <span class="dt">ylab=</span><span class="st">&quot;R&quot;</span>)
<span class="kw">abline</span>(<span class="dt">h=</span><span class="fl">1.2</span>, <span class="dt">lty=</span><span class="dv">2</span>)
<span class="kw">abline</span>(<span class="dt">h=</span><span class="fl">1.1</span>,<span class="dt">lty =</span> <span class="dv">2</span>)</code></pre></div>
<p><strong>The plot of <span class="math inline">\(R^2\)</span> is shown in the figure for time 1001 to 15000. From this plot it is evident that the chain is converging faster than when the proposal distribution had a very small variance. The value of <span class="math inline">\(R^2\)</span> is below 1.2 within 500 iterations and below 1.1 within 2000 iterations.</strong></p>
</div>
<div id="question-17" class="section level3">
<h3>Question</h3>
<p>Find the intersection points A(k) in <span class="math inline">\((0,\sqrt{k})\)</span> of the curves<span class="math display">\[S_{k - 1}(a) = P(t(k - 1) &gt; \sqrt{\frac{a^2(k  - 1)}{k - a^2}})\]</span> and <span class="math display">\[S_{k}(a) = P(t(k) &gt; \sqrt{\frac{a^2k}{k + 1 - a^2}})\]</span> for k = 4 : 25, 100, 500, 1000, where t(k) is a Student t random variable with k degrees of freedom.</p>
</div>
<div id="answer-14" class="section level3">
<h3>Answer</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">k &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span> <span class="op">:</span><span class="st"> </span><span class="dv">25</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>) <span class="co">#Declare the variables </span>
n &lt;-<span class="st"> </span><span class="kw">length</span>(k)
a &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,n) <span class="co">#store the intersection points</span>
eps &lt;-<span class="st"> </span>.Machine<span class="op">$</span>double.eps<span class="op">^</span><span class="fl">0.25</span> 
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  out &lt;-<span class="st"> </span><span class="kw">uniroot</span>(<span class="cf">function</span>(a){
    <span class="kw">pt</span>(<span class="kw">sqrt</span>(a<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(k[i] <span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(k[i] <span class="op">-</span><span class="st"> </span>a <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)),<span class="dt">df =</span> ( k[i] <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)) <span class="op">-</span><span class="st"> </span><span class="kw">pt</span>(<span class="kw">sqrt</span>(a <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>k[i] <span class="op">/</span>(k[i] <span class="op">+</span><span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>a <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)),<span class="dt">df =</span> k[i])},
    <span class="dt">lower =</span> eps, <span class="dt">upper =</span> <span class="kw">sqrt</span>(k[i] <span class="op">-</span><span class="st"> </span>eps) <span class="co">#the endpoints</span>
  )
  a[i] &lt;-<span class="st"> </span>out<span class="op">$</span>root
}
intsecp &lt;-<span class="st"> </span><span class="kw">rbind</span>(k,a)
<span class="co">#knitr::kable(intsecp)</span>
<span class="kw">print</span>(<span class="kw">round</span>(intsecp,<span class="dv">3</span>))
<span class="kw">plot</span>(k[<span class="dv">1</span><span class="op">:</span><span class="dv">19</span>] ,a[<span class="dv">1</span><span class="op">:</span><span class="dv">19</span>], <span class="dt">xlab =</span> <span class="st">&quot;k value(df)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;A(k)&quot;</span>)</code></pre></div>
<p><strong><em>From the tendency, we can find that when k increases, the intersection values increases too.</em></strong></p>
</div>
</div>
<div id="th-20181130" class="section level2">
<h2><font color="Teal">8th 2018/11/30</font></h2>
<div id="question-18" class="section level3">
<h3>Question</h3>
<p>Write a function to compute the cdf of the Cauchy distribution, which has density <span class="math display">\[\frac{1}{\theta\pi(1+[(x-\eta)/\theta]^2)},-\infty &lt; x &lt; \infty,\]</span> where <span class="math inline">\(\theta &gt; 0\)</span>. Compare your results to the results from the R function <span class="math inline">\(pcauchy\)</span>.</p>
</div>
<div id="answer-15" class="section level3">
<h3>Answer</h3>
<p><strong><em>step</em></strong></p>
<ul>
<li>First, we can generate the density function of cauchy distribution named pdf.</li>
<li>Then, I use the integrate function to compute the cdf.</li>
<li>At last, consider the special case <span class="math inline">\(\eta = 2 \quad and \quad \theta =3 ,\quad -15+\eta&lt;x&lt;15+\eta.\)</span> plot the cdf curve and compare the difference with pcauchy function.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="co"># generate the distribution function of cauchy distribution</span>
cdf &lt;-<span class="st"> </span><span class="cf">function</span>(x,eta,theta){
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  cdf &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
  <span class="co"># compute the density function of cauchy distribution</span>
  pdf &lt;-<span class="st"> </span><span class="cf">function</span>(y) <span class="dv">1</span><span class="op">/</span>(theta<span class="op">*</span><span class="st"> </span>pi <span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>((y<span class="op">-</span>eta)<span class="op">/</span>theta)<span class="op">^</span><span class="dv">2</span>))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span> <span class="op">:</span><span class="st"> </span>n){
    cdf[i] &lt;-<span class="st"> </span><span class="kw">integrate</span>(pdf, <span class="op">-</span><span class="ot">Inf</span>, x[i])<span class="op">$</span>value
  }
  <span class="kw">return</span>(cdf)
}
<span class="co"># consider the special case</span>
eta &lt;-<span class="st"> </span><span class="dv">2</span> 
theta &lt;-<span class="st"> </span><span class="dv">3</span>
x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">15</span> <span class="op">+</span><span class="st"> </span>eta, <span class="dv">15</span> <span class="op">+</span><span class="st"> </span>eta, .<span class="dv">01</span>)
<span class="kw">plot</span>(x, <span class="kw">cdf</span>(x,eta, theta),<span class="dt">type =</span> <span class="st">&quot;l&quot;</span>,<span class="dt">lwd =</span> <span class="dv">3</span>, <span class="dt">xlab =</span> <span class="st">&quot;x            eta = 2, theta = 3&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;cdf(x)&quot;</span>)
<span class="kw">lines</span>(x,<span class="kw">pcauchy</span>(x,eta,theta),<span class="dt">col =</span> <span class="dv">2</span>)
<span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;cdf&quot;</span>,<span class="st">&quot;pcauchy&quot;</span>), <span class="dt">lwd =</span> <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>),<span class="dt">col =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="co">#compute the difference</span>
<span class="kw">mean</span>(<span class="kw">cdf</span>(x,eta, theta) <span class="op">-</span><span class="st"> </span><span class="kw">pcauchy</span>(x))</code></pre></div>
<ul>
<li>From the figure, we find our method to compute cdf is feasible and the mean difference is very near to 0.</li>
</ul>
</div>
<div id="question-19" class="section level3">
<h3>Question</h3>
<ul>
<li>A-B-O blood type problem</li>
<li>Let the three alleles be A, B, and O.</li>
</ul>
</div>
</div>
<div id="th-20181207" class="section level2">
<h2><font color="Teal">9th 2018/12/07</font></h2>
<div id="question-20" class="section level3">
<h3>Question</h3>
<p>Use both for loops and <span class="math inline">\(lapply()\)</span> to fit linear models to the <span class="math inline">\(mtcars\)</span> using the formulas stored in this list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formulas &lt;-<span class="st"> </span><span class="kw">list</span>(
mpg <span class="op">~</span><span class="st"> </span>disp,
mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp),
mpg <span class="op">~</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>wt,
mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp) <span class="op">+</span><span class="st"> </span>wt
)</code></pre></div>
</div>
<div id="answer-16" class="section level3">
<h3>Answer</h3>
<p><strong><em>Here, fomulas is a list, and it varys. The data is mtcars which does not vary. So the argument of the function is the list formulas.</em></strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
## loop
out1 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(formulas))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(formulas)) {
  out1[[i]] &lt;-<span class="st"> </span><span class="kw">lm</span>(formulas[[i]],<span class="dt">data =</span> mtcars)
}

## lapply
(out1&lt;-<span class="kw">lapply</span>(formulas,<span class="cf">function</span>(x) <span class="kw">lm</span>(x,mtcars)))</code></pre></div>
</div>
<div id="question-21" class="section level3">
<h3>Question</h3>
<p>Fit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below by using a for loop and lapply(). Can you do it without an anonymous function?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bootstraps &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="cf">function</span>(i) {
rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(mtcars), <span class="dt">rep =</span> <span class="ot">TRUE</span>)
mtcars[rows, ]
})</code></pre></div>
</div>
<div id="answer-17" class="section level3">
<h3>Answer</h3>
<p><strong><em>Differently, the linear function does not vary but the input varies i.e. the bootrap is a list. So the argument of the function is the list bootstraps.</em></strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## loop
out2 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(bootstraps))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(bootstraps)) {
  out2[[i]] &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>disp,bootstraps[[i]])
}
## lapply
(out2 &lt;-<span class="st"> </span><span class="kw">lapply</span>(bootstraps, <span class="cf">function</span>(x) <span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>disp,x)))</code></pre></div>
</div>
<div id="question-22" class="section level3">
<h3>Question</h3>
<p>For each model in the previous two exercises, extract R2 using the function below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rsq &lt;-<span class="st"> </span><span class="cf">function</span>(mod) <span class="kw">summary</span>(mod)<span class="op">$</span>r.squared</code></pre></div>
</div>
<div id="answer-18" class="section level3">
<h3>Answer</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">2</span>)
<span class="co"># out is the linear model generated in ex3 and ex4.</span>
out &lt;-<span class="st"> </span><span class="kw">c</span>(out1,out2) 
(R_sqr &lt;-<span class="st"> </span><span class="kw">sapply</span>(out, rsq))
<span class="kw">plot</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">14</span>,R_sqr,<span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))</code></pre></div>
</div>
<div id="question-23" class="section level3">
<h3>Question</h3>
<p>The following code simulates the performance of a t-test for non-normal data. Use sapply() and an anonymous function to extract the p-value from every trial.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trials &lt;-<span class="st"> </span><span class="kw">replicate</span>(
<span class="dv">100</span>,
<span class="kw">t.test</span>(<span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">rpois</span>(<span class="dv">7</span>, <span class="dv">10</span>)),
<span class="dt">simplify =</span> <span class="ot">FALSE</span>
)</code></pre></div>
<p>Extra challenge: get rid of the anonymous function by using [[ directly.</p>
</div>
<div id="answer-19" class="section level3">
<h3>Answer</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">##sapply
<span class="kw">sapply</span>(trials, <span class="cf">function</span>(x) x<span class="op">$</span>p.value)

##get rid of the anonymous function
<span class="kw">sapply</span>(trials, <span class="st">`</span><span class="dt">[[</span><span class="st">`</span>, <span class="st">'p.value'</span>)</code></pre></div>
<p><strong><em>Conclusion: We cannot reject H0 significantly for most p-values is lower than 0.05. </em></strong></p>
<p><strong><em>And actually the data come from the same distribution <span class="math inline">\(Poisson(10)\)</span></em></strong></p>
</div>
<div id="question-24" class="section level3">
<h3>Question</h3>
<p>Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?</p>
</div>
<div id="answer-20" class="section level3">
<h3>Answer</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
mcvMap &lt;-<span class="st"> </span><span class="cf">function</span>(f, FUN.VALUE , ...) {
    out &lt;-<span class="st"> </span><span class="kw">mcMap</span>(f, ...)
    <span class="kw">vapply</span>(out, identity, FUN.VALUE)
}</code></pre></div>
<p><strong><em>We can use parallel or foreach packages to do iterates in parallel.</em></strong></p>
</div>
</div>
<div id="th-20181214" class="section level2">
<h2><font color="Teal">10th 2018/12/14</font></h2>
</div>
<div id="question-25" class="section level2">
<h2>Question</h2>
<p>Make a faster version of <strong>chisq.test()</strong> that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying <strong>chisq.test()</strong> or by coding from the mathematical definition (<a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test">http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test</a>).</p>
</div>
<div id="answer-21" class="section level2">
<h2>Answer</h2>
<p><bra></bra></p>
<p><strong><em>Analysis</em></strong></p>
<ul>
<li><p><em>chisq.test()</em> performs chi-squared contingency table tests and goodness-of-fit tests.</p></li>
<li><p>Calculate the chi-squared test statistic, <span class="math inline">\(\chi ^{2}\)</span>, which resembles a normalized sum of squared deviations between observed and theoretical frequencies.</p></li>
<li><p>The value of the test-statistic is<br />
<span class="math display">\[\chi ^{2}=\sum _{i=1}^{r}\sum _{j=1}^{c}\frac{(O_{i,j}-E_{i,j})^{2}}{E_{i,j}}\]</span> <span class="math display">\[E_{i,j} = N \cdot p_{i,j} = N \cdot p_{i\cdot} \cdot p_{\cdot j} = \frac{E_{i\cdot} \cdot E_{\cdot j}}{N}\]</span> here, c = 2 because the input is two numeric vectors with no missing values.</p></li>
<li><p>Determine the degrees of freedom, df, of that statistic.<span class="math display">\[df = (r - 1)??(c - 1) = r - 1, \qquad c=2.\]</span></p></li>
<li><p>Select a desired level of confidence for the result of the test.</p></li>
<li><p>Compare <span class="math inline">\(\chi ^{2}\)</span> to the critical value from the chi-squared distribution with df degrees of freedom and the selected confidence level , which in many cases gives a good approximation of the distribution of <span class="math inline">\(\chi ^{2}\)</span>.</p></li>
<li><p>Use <span class="math inline">\(microbenchmark::microbenchmark\)</span> to compare with the version of <span class="math inline">\(chisq.test()\)</span> <bra></bra></p></li>
</ul>
<p><bra></bra><bra></bra><bra></bra></p>
<p><strong><em>Code</em></strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Testing for statistical independence</span>
## 
chisq_test &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  m &lt;-<span class="st"> </span><span class="kw">nrow</span>(x);  n &lt;-<span class="st"> </span><span class="kw">ncol</span>(x); N &lt;-<span class="st"> </span><span class="kw">sum</span>(x)
  E &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,m,n)
  rowsums &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span>m, <span class="cf">function</span>(i) <span class="kw">sum</span>(x[i,]))) <span class="co"># which is used to computed pi.</span>
  colsums &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span>n, <span class="cf">function</span>(j) <span class="kw">sum</span>(x[,j])))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
      E[i,j] &lt;-<span class="st"> </span>rowsums[i]<span class="op">*</span>colsums[j]<span class="op">/</span>N
    }
  }
  df &lt;-<span class="st"> </span>(m<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)
  chi_sqr &lt;-<span class="st"> </span><span class="kw">sum</span>((x<span class="op">-</span>E)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E) <span class="co">#</span>
  p_value &lt;-<span class="st"> </span><span class="kw">dchisq</span>(chi_sqr, <span class="dt">df =</span> df)
  (test &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">chi_sqr =</span> chi_sqr, <span class="dt">df =</span> df, <span class="dt">p_value =</span> p_value))
}

  <span class="co"># chisq.test() </span>
  ## From Agresti(2007) p.39
M &lt;-<span class="st"> </span><span class="kw">as.table</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">762</span>, <span class="dv">327</span>, <span class="dv">468</span>), <span class="kw">c</span>(<span class="dv">484</span>, <span class="dv">239</span>, <span class="dv">477</span>)))
<span class="kw">dimnames</span>(M) &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">gender =</span> <span class="kw">c</span>(<span class="st">&quot;F&quot;</span>, <span class="st">&quot;M&quot;</span>),
                    <span class="dt">party =</span> <span class="kw">c</span>(<span class="st">&quot;Democrat&quot;</span>,<span class="st">&quot;Independent&quot;</span>, <span class="st">&quot;Republican&quot;</span>))
(M)</code></pre></div>
<pre><code>##       party
## gender Democrat Independent Republican
##      F      762         327        468
##      M      484         239        477</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(Xsq &lt;-<span class="st"> </span><span class="kw">chisq.test</span>(M))  <span class="co"># Prints test summary</span></code></pre></div>
<pre><code>## 
##  Pearson's Chi-squared test
## 
## data:  M
## X-squared = 30.07, df = 2, p-value = 2.954e-07</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chisq_test</span>(M)</code></pre></div>
<pre><code>## $chi_sqr
## [1] 30.07015
## 
## $df
## [1] 2
## 
## $p_value
## [1] 1.476795e-07</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(
  <span class="kw">chisq_test</span>(M),
  <span class="kw">chisq.test</span>(M)
))</code></pre></div>
<pre><code>## Unit: microseconds
##           expr     min       lq     mean  median       uq      max neval
##  chisq_test(M)  62.403  68.3560 109.8217  80.673 125.8325  413.010   100
##  chisq.test(M) 130.144 141.8445 227.7471 153.545 215.7430 1426.239   100</code></pre>
<p><strong><em>Conclusion</em></strong></p>
<p>We can say that calling <em>chisq_test()</em> quite a bit faster than calling <em>chisq.test()</em> for two numeric vectors with no missing values.</p>
</div>
<div id="question-26" class="section level2">
<h2>Question</h2>
<p>Can you make a faster version of <em>table()</em> for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?</p>
</div>
<div id="answer-22" class="section level2">
<h2>Answer</h2>
<p><bra></bra></p>
<p><strong><em>Analysis</em></strong></p>
<ul>
<li><em>table()</em> uses the cross-classifying factors to build a contingency table of the counts at each combination of factor levels.</li>
<li>I use <em>unique(), class()</em> to get <em>table2()</em> function and then use <em>indentical()</em> to check.</li>
<li>I use table on the pair of factors (e.g. Group and race) and then use that as input to <em>chisq_test()</em>.</li>
</ul>
<p><bra></bra></p>
<p><strong><em>Code</em></strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  x_val &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">unique</span>(x)); y_val &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">unique</span>(y)) <span class="co"># remove the duplicate elements</span>
  m &lt;-<span class="st"> </span><span class="kw">length</span>(x_val); n &lt;-<span class="st"> </span><span class="kw">length</span>(y_val) <span class="co"># dimensions of the table </span>
  mat &lt;-<span class="st"> </span><span class="kw">matrix</span>(0L, m, n)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    mat[<span class="kw">which</span>(x_val <span class="op">==</span><span class="st"> </span>x[[i]]), <span class="kw">which</span>(y_val <span class="op">==</span><span class="st"> </span>y[[i]])] &lt;-
<span class="st">      </span>mat[<span class="kw">which</span>(x_val <span class="op">==</span><span class="st"> </span>x[[i]]),  <span class="kw">which</span>(y_val <span class="op">==</span><span class="st"> </span>y[[i]])] <span class="op">+</span><span class="st"> </span>1L
  }
  dimnames &lt;-<span class="st"> </span><span class="kw">list</span>(x_val, y_val)
  <span class="kw">names</span>(dimnames) &lt;-<span class="st"> </span><span class="kw">as.character</span>(<span class="kw">as.list</span>(<span class="kw">match.call</span>())[<span class="op">-</span><span class="dv">1</span>])  <span class="co"># R has names for dimnames... :/</span>
  table &lt;-<span class="st"> </span><span class="kw">array</span>(mat, <span class="dt">dim =</span> <span class="kw">dim</span>(mat), <span class="dt">dimnames =</span> dimnames)
  <span class="kw">class</span>(table) &lt;-<span class="st"> &quot;table&quot;</span>
  table
}
<span class="co"># Example:generate random samples.</span>
data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">group=</span><span class="kw">as.factor</span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>,<span class="dv">100</span>,<span class="ot">TRUE</span>)),
                     <span class="dt">race=</span><span class="kw">as.factor</span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,<span class="dv">100</span>,<span class="ot">TRUE</span>)))
<span class="co"># look at the table</span>
tab1 &lt;-<span class="st"> </span><span class="kw">with</span>(data,<span class="kw">table</span>(group,race))
tab2 &lt;-<span class="st"> </span><span class="kw">with</span>(data,<span class="kw">table2</span>(group,race))
<span class="co"># Check whether the table2 is same with table function</span>
<span class="kw">identical</span>(tab1,tab2)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Use it to speed up your chi-square test for testing </span>
<span class="kw">chisq_test</span>(tab1)</code></pre></div>
<pre><code>## $chi_sqr
## [1] 10.2435
## 
## $df
## [1] 6
## 
## $p_value
## [1] 0.03912271</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(<span class="kw">chisq_test</span>(tab1), <span class="kw">chisq_test</span>(tab2))</code></pre></div>
<pre><code>## Unit: microseconds
##              expr    min      lq     mean   median       uq      max neval
##  chisq_test(tab1) 80.057 86.6255 185.1775 148.4135 177.3565 2408.266   100
##  chisq_test(tab2) 78.825 87.2415 151.7878 138.7650 169.7615  676.581   100</code></pre>
<p><strong><em>Conclusion</em></strong></p>
<p>We can use it to speed up your chi-square test, but not very efficeient.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
